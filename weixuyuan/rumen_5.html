
<h1>Java继承的概念与实现</h1>
<div id="art-body">继承是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承（例如儿子继承父亲财产）类似。<br>
<br>
继承可以理解为一个类从另一个类获取方法和属性的过程。如果类B继承于类A，那么B就拥有A的方法和属性。<br>
<br>
继承使用 extends 关键字。<br>
<br>
例如我们已经定义了一个类 People：
<pre class="java">
class People{
    String name;
    int age;
    int height;
   
    void say(){
        System.out.println("我的名字是 " + name + "，年龄是 " + age + "，身高是 " + height);
    }
}</pre>
如果现在需要定义一个类 Teacher，它也有 name、age、height 属性和 say() 方法，另外还需要增加 school、seniority、subject 属性和 lecturing() 方法，怎么办呢？我们要重新定义一个类吗？<br>
<br>
完全没必要，可以先继承 People 类的成员，再增加自己的成员即可，例如：
<pre class="java">
class Teacher extends People{
    String school;  // 所在学校
    String subject;  // 学科
    int seniority;  // 教龄
   
    // 覆盖 People 类中的 say() 方法
    void say(){
        System.out.println("我叫" + name + "，在" + school + "教" + subject + "，有" + seniority + "年教龄");
    }
   
    void lecturing(){
        System.out.println("我已经" + age + "岁了，依然站在讲台上讲课");
    }
}</pre>
对程序的说明
<ul>
<li>
name 和 age 变量虽然没有在 Teacher 中定义，但是已在 People 中定义，可以直接拿来用。</li>
<li>
Teacher 是 People 的子类，People 是Teacher 类的父类。</li>
<li>
子类可以覆盖父类的方法。</li>
<li>
子类可以继承父类除private以为的所有的成员。</li>
<li>
构造方法不能被继承。</li>
</ul>
<br>
继承是在维护和可靠性方面的一个伟大进步。如果在 People 类中进行修改，那么 Teacher 类就会自动修改，而不需要程序员做任何工作，除了对它进行编译。<br>
<br>
单继承性：Java 允许一个类仅能继承一个其它类，即一个类只能有一个父类，这个限制被称做单继承性。后面将会学到接口(interface)的概念，接口允许多继承。<br>
<br>
最后对上面的代码进行整理：
<pre class="java">
public class Demo {
    public static void main(String[] args) {
        Teacher t = new Teacher();
        t.name = "小布";
        t.age = 70;
        t.school = "清华大学";
        t.subject = "Java";
        t.seniority = 12;
        t.say();
        t.lecturing();
    }
}

class People{
    String name;
    int age;
    int height;
   
    void say(){
        System.out.println("我的名字是 " + name + "，年龄是 " + age + "，身高是 " + height);
    }
}

class Teacher extends People{
    String school;  // 所在学校
    String subject;  // 学科
    int seniority;  // 教龄
   
    // 覆盖 People 类中的 say() 方法
    void say(){
        System.out.println("我叫" + name + "，在" + school + "教" + subject + "，有" + seniority + "年教龄");
    }
   
    void lecturing(){
        System.out.println("我已经" + age + "岁了，依然站在讲台上讲课");
    }
}</pre>
运行结果：<br>
我叫小布，在清华大学教Java，有12年教龄<br>
我已经70岁了，依然站在讲台上讲课<br>
<br>
<span style="color:#b22222;">注意：构造方法不能被继承，掌握这一点很重要。 一个类能得到构造方法，只有两个办法：编写构造方法，或者根本没有构造方法，类有一个默认的构造方法。</span></div>

http://www.weixueyuan.net/view/5996.html
<h1>Java super关键字</h1>
<div id="art-body">super 关键字与 <a href="/view/5988.html" target="_blank">this</a> 类似，this 用来表示当前类的实例，super 用来表示父类。<br>
<br>
super 可以用在子类中，通过点号(.)来获取父类的成员变量和方法。super 也可以用在子类的子类中，Java 能自动向上层类追溯。<br>
<br>
父类行为被调用，就好象该行为是本类的行为一样，而且调用行为不必发生在父类中，它能自动向上层类追溯。<br>
<br>
super 关键字的功能：
<ul>
<li>
调用父类中声明为 private 的变量。</li>
<li>
点取已经覆盖了的方法。</li>
<li>
作为方法名表示父类构造方法。</li>
</ul>
<h2>
调用隐藏变量和被覆盖的方法</h2>
<pre class="java">
public class Demo{
    public static void main(String[] args) {
        Dog obj = new Dog();
        obj.move();
    }
}
class Animal{
    private String desc = "Animals are human's good friends";
    // 必须要声明一个 getter 方法
    public String getDesc() { return desc; }

    public void move(){
        System.out.println("Animals can move");
    }
}
class Dog extends Animal{
    public void move(){
        super.move();  // 调用父类的方法
        System.out.println("Dogs can walk and run");
        // 通过 getter 方法调用父类隐藏变量
        System.out.println("Please remember: " + super.getDesc());
    }
}</pre>
运行结果：<br>
Animals can move<br>
Dogs can walk and run<br>
Please remember: Animals are human's good friends<br>
<br>
move() 方法也可以定义在某些祖先类中，比如父类的父类，Java 具有追溯性，会一直向上找，直到找到该方法为止。<br>
<br>
通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。
<h2>
调用父类的构造方法</h2>
在许多情况下，使用默认构造方法来对父类对象进行初始化。当然也可以使用 super 来显示调用父类的构造方法。
<pre class="java">
public class Demo{
    public static void main(String[] args) {
        Dog obj = new Dog("花花", 3);
        obj.say();
    }
}
class Animal{
    String name;
    public Animal(String name){
        this.name = name;
    }
}
class Dog extends Animal{
    int age;
    public Dog(String name, int age){
        super(name);
        this.age = age;
    }

    public void say(){
        System.out.println("我是一只可爱的小狗，我的名字叫" + name + "，我" + age + "岁了");
    }
}</pre>
运行结果：<br>
我是一只可爱的小狗，我的名字叫花花，我3岁了<br>
<br>
注意：无论是 super() 还是 this()，都必须放在构造方法的第一行。<br>
<br>
值得注意的是：
<ul>
<li>
在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。</li>
<li>
不能在构造方法以外的任何方法内调用构造方法。</li>
<li>
在一个构造方法内只能调用一个构造方法。</li>
</ul>
<br>
如果编写一个构造方法，既没有调用 super() 也没有调用 this()，编译器会自动插入一个调用到父类构造方法中，而且不带参数。 <br>
<br>
<span style="color:#b22222;">最后注意 super 与 this 的区别：super 不是一个对象的引用，不能将 super 赋值给另一个对象变量，它只是一个指示编译器调用父类方法的特殊关键字。</span></div>

http://www.weixueyuan.net/view/5998.html
<h1>Java继承中方法的覆盖和重载</h1>
<div id="art-body">在类继承中，子类可以修改从父类继承来的方法，也就是说子类能创建一个与父类方法有不同功能的方法，但具有相同的名称、返回值类型、参数列表。<br>
<br>
如果在新类中定义一个方法，其名称、返回值类型和参数列表正好与父类中的相同，那么，新方法被称做覆盖旧方法。<br>
<br>
参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。<br>
<br>
被覆盖的方法在子类中只能通过super调用。<br>
<br>
注意：覆盖不会删除父类中的方法，而是对子类的实例隐藏，暂时不使用。<br>
<br>
请看下面的例子：
<pre class="java">
public class Demo{
    public static void main(String[] args) {
        Dog myDog = new Dog("花花");
        myDog.say();  // 子类的实例调用子类中的方法
       
        Animal myAnmial = new Animal("贝贝");
        myAnmial.say();  // 父类的实例调用父类中的方法
    }
}
class Animal{
    String name;
    public Animal(String name){
        this.name = name;
    }
   
    public void say(){
        System.out.println("我是一只小动物，我的名字叫" + name + "，我会发出叫声");
    }
}
class Dog extends Animal{
    // 构造方法不能被继承，通过super()调用
    public Dog(String name){
        super(name);
    }

    // 覆盖say() 方法
    public void say(){
        System.out.println("我是一只小狗，我的名字叫" + name + "，我会发出汪汪的叫声");
    }
}</pre>
运行结果：<br>
我是一只小狗，我的名字叫花花，我会发出汪汪的叫声<br>
我是一只小动物，我的名字叫贝贝，我会发出叫声<br>
<br>
<strong>方法覆盖的原则：</strong>
<ul>
<li>
覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。</li>
<li>
覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。</li>
<li>
覆盖方法不能比原方法抛出更多的异常。</li>
<li>
被覆盖的方法不能是final类型，因为final修饰的方法是无法覆盖的。</li>
<li>
被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li>
<li>
被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。</li>
</ul>
<br>
<strong>方法的重载：</strong><br>
前面已经对<a href="/view/5989.html" target="_blank">Java方法重载</a>进行了说明，这里再强调一下，Java父类和子类中的方法都会参与重载，例如，父类中有一个方法是 func(){ ... }，子类中有一个方法是 func(int i){ ... }，就构成了方法的重载。<br>
<br>
<strong>覆盖和重载的不同：</strong>
<ul>
<li>
方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。</li>
<li>
方法覆盖要求返回类型必须一致，方法重载对此没有要求。</li>
<li>
方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。</li>
<li>
方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。</li>
<li>
父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次。</li>
</ul>
</div>

http://www.weixueyuan.net/view/5999.html
<h1>Java多态和动态绑定</h1>
<div id="art-body">在Java中，父类的变量可以引用父类的实例，也可以引用子类的实例。<br>
<br>
请读者先看一段代码：
<pre class="java">
public class Demo {
    public static void main(String[] args){
        Animal obj = new Animal();
        obj.cry();

        obj = new Cat();
        obj.cry();

        obj = new Dog();
        obj.cry();
    }
}

class Animal{
    // 动物的叫声
    public void cry(){
        System.out.println("不知道怎么叫");
    }
   
}

class Cat extends Animal{
    // 猫的叫声
    public void cry(){
        System.out.println("喵喵~");
    }
}

class Dog extends Animal{
    // 狗的叫声
    public void cry(){
        System.out.println("汪汪~");
    }
}</pre>
运行结果：<br>
不知道怎么叫<br>
喵喵~<br>
汪汪~<br>
<br>
上面的代码，定义了三个类，分别是 Animal、Cat 和 Dog，Cat 和 Dog 类都继承自 Animal 类。obj 变量的类型为 Animal，它既可以指向 Animal 类的实例，也可以指向 Cat 和 Dog 类的实例，这是正确的。也就是说，父类的变量可以引用父类的实例，也可以引用子类的实例。注意反过来是错误的，因为所有的猫都是动物，但不是所有的动物都是猫。<br>
<br>
可以看出，obj 既可以是人类，也可以是猫、狗，它有不同的表现形式，这就被称为<span style="color:#b22222;">多态</span>。多态是指一个事物有不同的表现形式或形态。<br>
<br>
再比如“人类”，也有很多不同的表达或实现，TA 可以是司机、教师、医生等，你憎恨自己的时候会说“下辈子重新做人”，那么你下辈子成为司机、教师、医生都可以，我们就说“人类”具备了多态性。<br>
<br>
<span style="color:#b22222;">多态存在的三个必要条件：要有继承、要有重写、父类变量引用子类对象。</span><br>
<br>
当使用多态方式调用方法时：
<ul>
<li>
首先检查父类中是否有该方法，如果没有，则编译错误；如果有，则检查子类是否覆盖了该方法。</li>
<li>
如果子类覆盖了该方法，就调用子类的方法，否则调用父类方法。</li>
</ul>
<br>
从上面的例子可以看出，多态的一个好处是：当子类比较多时，也不需要定义多个变量，可以只定义一个父类类型的变量来引用不同子类的实例。请再看下面的一个例子：
<pre class="java">
public class Demo {
    public static void main(String[] args){
        // 借助多态，主人可以给很多动物喂食
        Master ma = new Master();
        ma.feed(new Animal(), new Food());
        ma.feed(new Cat(), new Fish());
        ma.feed(new Dog(), new Bone());
    }
}

// Animal类及其子类
class Animal{
    public void eat(Food f){
        System.out.println("我是一个小动物，正在吃" + f.getFood());
    }
}

class Cat extends Animal{
    public void eat(Food f){
        System.out.println("我是一只小猫咪，正在吃" + f.getFood());
    }
}

class Dog extends Animal{
    public void eat(Food f){
        System.out.println("我是一只狗狗，正在吃" + f.getFood());
    }
}

// Food及其子类
class Food{
    public String getFood(){
        return "事物";
    }
}

class Fish extends Food{
    public String getFood(){
        return "鱼";
    }
}

class Bone extends Food{
    public String getFood(){
        return "骨头";
    }
}

// Master类
class Master{
    public void feed(Animal an, Food f){
        an.eat(f);
    }
}</pre>
运行结果：<br>
我是一个小动物，正在吃事物<br>
我是一只小猫咪，正在吃鱼<br>
我是一只狗狗，正在吃骨头<br>
<br>
Master 类的 feed 方法有两个参数，分别是 Animal 类型和 Food 类型，因为是父类，所以可以将子类的实例传递给它，这样 Master 类就不需要多个方法来给不同的动物喂食。<br>
<h2>
动态绑定</h2>
为了理解多态的本质，下面讲一下Java调用方法的详细流程。<br>
<br>
1) 编译器查看对象的声明类型和方法名。<br>
<br>
假设调用 obj.func(param)，obj 为 Cat 类的对象。需要注意的是，有可能存在多个名字为func但参数签名不一样的方法。例如，可能存在方法 func(int) 和 func(String)。编译器将会一一列举所有 Cat 类中名为func的方法和其父类 Animal 中访问属性为 public 且名为func的方法。<br>
<br>
这样，编译器就获得了所有可能被调用的候选方法列表。<br>
<br>
2) 接下来，编泽器将检查调用方法时提供的参数签名。<br>
<br>
如果在所有名为func的方法中存在一个与提供的参数签名完全匹配的方法，那么就选择这个方法。这个过程被称为<span style="color:#b22222;">重载解析(overloading resolution)</span>。例如，如果调用 func("hello")，编译器会选择 func(String)，而不是 func(int)。由于自动类型转换的存在，例如 int 可以转换为 double，如果没有找到与调用方法参数签名相同的方法，就进行类型转换后再继续查找，如果最终没有匹配的类型或者有多个方法与之匹配，那么编译错误。<br>
<br>
这样，编译器就获得了需要调用的方法名字和参数签名。<br>
<br>
3) 如果方法的修饰符是private、static、final（static和final将在后续讲解），或者是构造方法，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式 称为<span style="color:#b22222;">静态绑定(static binding)</span>。<br>
<br>
与此对应的是，调用的方法依赖于对象的实际类型， 并在运行时实现动态绑。例如调用 func("hello")，编泽器将采用动态绑定的方式生成一条调用 func(String) 的指令。<br>
<br>
4)当程序运行，并且釆用动态绑定调用方法时，JVM一定会调用与 obj 所引用对象的实际类型最合适的那个类的方法。我们已经假设 obj 的实际类型是 Cat，它是 Animal 的子类，如果 Cat 中定义了 func(String)，就调用它，否则将在 Animal 类及其父类中寻找。<br>
<br>
每次调用方法都要进行搜索，时间开销相当大，因此，JVM预先为每个类创建了一个<span style="color:#b22222;">方法表(method lable)</span>，其中列出了所有方法的名称、参数签名和所属的类。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。在上面的例子中，JVM 搜索 Cat 类的方法表，以便寻找与调用 func("hello") 相匹配的方法。这个方法既有可能是 Cat.func(String)，也有可能是 Animal.func(String)。注意，如果调用super.func("hello")，编译器将对父类的方法表迸行搜索。<br>
<br>
假设 Animal 类包含cry()、getName()、getAge() 三个方法，那么它的方法表如下：<br>
cry() -&gt; Animal.cry()<br>
getName() -&gt; Animal.getName()<br>
getAge() -&gt; Animal.getAge()<br>
<br>
实际上，Animal 也有默认的父类 Object（后续会讲解），会继承 Object 的方法，所以上面列举的方法并不完整。<br>
<br>
假设 Cat 类覆盖了 Animal 类中的 cry() 方法，并且新增了一个方法 climbTree()，那么它的参数列表为：<br>
cry() -&gt; Cat.cry()<br>
getName() -&gt; Animal.getName()<br>
getAge() -&gt; Animal.getAge()<br>
climbTree() -&gt; Cat.climbTree()<br>
<br>
在运行的时候，调用 obj.cry() 方法的过程如下：
<ul>
<li>
JVM 首先访问 obj 的实际类型的方法表，可能是 Animal 类的方法表，也可能是 Cat 类及其子类的方法表。</li>
<li>
JVM 在方法表中搜索与 cry() 匹配的方法，找到后，就知道它属于哪个类了。</li>
<li>
JVM 调用该方法。</li>
</ul>
</div>

http://www.weixueyuan.net/view/6000.html
<h1>Java instanceof 运算符</h1>
<div id="art-body">多态性带来了一个问题，就是如何判断一个变量所实际引用的对象的类型 。 C++使用runtime-type information(RTTI)，Java 使用 instanceof 操作符。<br>
<br>
instanceof 运算符用来判断一个变量所引用的对象的实际类型，注意是它引用的对象的类型，不是变量的类型。请看下面的代码：
<pre class="java">
public final class Demo{
    public static void main(String[] args) {
        // 引用 People 类的实例
        People obj = new People();
        if(obj instanceof Object){
            System.out.println("我是一个对象");
        }
        if(obj instanceof People){
            System.out.println("我是人类");
        }
        if(obj instanceof Teacher){
            System.out.println("我是一名教师");
        }
        if(obj instanceof President){
            System.out.println("我是校长");
        }

        System.out.println("-----------");  // 分界线
       
        // 引用 Teacher 类的实例
        obj = new Teacher();
        if(obj instanceof Object){
            System.out.println("我是一个对象");
        }
        if(obj instanceof People){
            System.out.println("我是人类");
        }
        if(obj instanceof Teacher){
            System.out.println("我是一名教师");
        }
        if(obj instanceof President){
            System.out.println("我是校长");
        }
    }
}

class People{ }
class Teacher extends People{ }
class President extends Teacher{ }</pre>
运行结果：<br>
我是一个对象<br>
我是人类<br>
-----------<br>
我是一个对象<br>
我是人类<br>
我是一名教师<br>
<br>
可以看出，如果变量引用的是当前类或它的子类的实例，instanceof 返回 true，否则返回 false。</div>

http://www.weixueyuan.net/view/6001.html
<h1>Java多态对象的类型转换</h1>
<div id="art-body">这里所说的对象类型转换，是指存在继承关系的对象，不是任意类型的对象。当对不存在继承关系的对象进行强制类型转换时，java 运行时将抛出 java.lang.ClassCastException 异常。<br>
<br>
在继承链中，我们将子类向父类转换称为“向上转型”，将父类向子类转换称为“向下转型”。<br>
<br>
很多时候，我们会将变量定义为父类的类型，却引用子类的对象，这个过程就是向上转型。程序运行时通过动态绑定来实现对子类方法的调用，也就是多态性。<br>
<br>
然而有些时候为了完成某些父类没有的功能，我们需要将向上转型后的子类对象再转成子类，调用子类的方法，这就是向下转型。<br>
<br>
注意：不能直接将父类的对象强制转换为子类类型，只能将向上转型后的子类对象再次转换为子类类型。<span style="color:#b22222;">也就是说，子类对象必须向上转型后，才能再向下转型。</span>请看下面的代码：
<pre class="java">
public class Demo {
    public static void main(String args[]) {
        SuperClass superObj = new SuperClass();
        SonClass sonObj = new SonClass();

        // 下面的代码运行时会抛出异常，不能将父类对象直接转换为子类类型
        // SonClass sonObj2 = (SonClass)superObj;

        // 先向上转型，再向下转型
        superObj = sonObj;
        SonClass sonObj1 = (SonClass)superObj;
    }
}

class SuperClass{ }
class SonClass extends SuperClass{ } </pre>
将第7行的注释去掉，运行时会抛出异常，但是编译可以通过。<br>
<br>
因为向下转型存在风险，所以在接收到父类的一个引用时，请务必使用 instanceof 运算符来判断该对象是否是你所要的子类，请看下面的代码：
<pre class="java">
public class Demo {
    public static void main(String args[]) {
        SuperClass superObj = new SuperClass();
        SonClass sonObj = new SonClass();

        // superObj 不是 SonClass 类的实例
        if(superObj instanceof SonClass){
            SonClass sonObj1 = (SonClass)superObj;
        }else{
            System.out.println("①不能转换");
        }

        superObj = sonObj;
        // superObj 是 SonClass 类的实例
        if(superObj instanceof SonClass){
            SonClass sonObj2 = (SonClass)superObj;
        }else{
            System.out.println("②不能转换");
        }
    }
}

class SuperClass{ }
class SonClass extends SuperClass{ }</pre>
运行结果：<br>
①不能转换<br>
<br>
总结：对象的类型转换在程序运行时检查，向上转型会自动进行，向下转型的对象必须是当前引用类型的子类。<br>
</div>

http://www.weixueyuan.net/view/6002.html
<h1>Java static关键字以及Java静态变量和静态方法</h1>
<div id="art-body">static 修饰符能够与变量、方法一起使用，表示是“静态”的。<br>
<br>
静态变量和静态方法能够通过类名来访问，不需要创建一个类的对象来访问该类的静态成员，所以static修饰的成员又称作类变量和类方法。静态变量与实例变量不同，实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。<br>
<br>
请看下面的例子：
<pre class="java">
public class Demo {
    static int i = 10;
    int j;

    Demo() {
        this.j = 20;
    }

    public static void main(String[] args) {
        System.out.println("类变量 i=" + Demo.i);
        Demo obj = new Demo();
        System.out.println("实例变量 j=" + obj.j);
    }
}</pre>
运行结果：<br>
类变量 i=10<br>
实例变量 j=20<br>
<h2>
static 的内存分配</h2>
静态变量属于类，不属于任何独立的对象，所以无需创建类的实例就可以访问静态变量。之所以会产生这样的结果，是因为编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然有多个实例，但这些实例共享该内存。实例变量则不同，每创建一个对象，都会分配一次内存空间，不同变量的内存相互独立，互不影响，改变 a 对象的实例变量不会影响 b 对象。<br>
<br>
请看下面的代码：
<pre class="java">
public class Demo {
    static int i;
    int j;

    public static void main(String[] args) {
        Demo obj1 = new Demo();
        obj1.i = 10;
        obj1.j = 20;
       
        Demo obj2 = new Demo();
       
        System.out.println("obj1.i=" + obj1.i + ", obj1.j=" + obj1.j);
        System.out.println("obj2.i=" + obj2.i + ", obj2.j=" + obj2.j);
    }
}</pre>
运行结果：<br>
obj1.i=10, obj1.j=20<br>
obj2.i=10, obj2.j=0<br>
<br>
注意：静态变量虽然也可以通过对象来访问，但是不被提倡，编译器也会产生警告。<br>
<br>
上面的代码中，i 是静态变量，通过 obj1 改变 i 的值，会影响到 obj2；j 是实例变量，通过 obj1 改变 j 的值，不会影响到 obj2。这是因为 obj1.i 和 obj2.i 指向同一个内存空间，而 obj1.j 和 obj2.j 指向不同的内存空间，请看下图：
<div style="text-align: center;">
<img alt="" src="http://www.weixueyuan.net/uploads/allimg/150103/8-150103095602439.png" style="width: 258px; height: 320px;"><br>
图1  静态变量内存分配</div>
<br>
注意：static 的变量是在类装载的时候就会被初始化。也就是说，只要类被装载，不管你是否使用了这个static 变量，它都会被初始化。<br>
<br>
小结：类变量(class variables)用关键字 static 修饰，在类加载的时候，分配类变量的内存，以后再生成类的实例对象时，将共享这块内存（类变量），任何一个对象对类变量的修改，都会影响其它对象。外部有两种访问方式：通过对象来访问或通过类名来访问。
<h2>
静态方法</h2>
静态方法是一种不能向对象实施操作的方法。例如，Math 类的 pow() 方法就是一个静态方法，语法为 Math.pow(x, a)，用来计算 x 的 a 次幂，在使用时无需创建任何 Math 对象。<br>
<br>
因为静态方法不能操作对象，所以不能在静态方法中访问实例变量，只能访问自身类的静态变量。<br>
<br>
以下情形可以使用静态方法：
<ul>
<li>
一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如 Math.pow()）。</li>
<li>
一个方法只需要访问类的静态变量。</li>
</ul>
<br>
读者肯定注意到，main() 也是一个静态方法，不对任何对象进行操作。实际上，在程序启动时还没有任何对象，main() 方法是程序的入口，将被执行并创建程序所需的对象。<br>
<br>
关于静态变量和静态方法的总结：
<ul>
<li>
一个类的静态方法只能访问静态变量；</li>
<li>
一个类的静态方法不能够直接调用非静态方法；</li>
<li>
如访问控制权限允许，静态变量和静态方法也可以通过对象来访问，但是不被推荐；</li>
<li>
静态方法中不存在当前对象，因而不能使用 this，当然也不能使用 super；</li>
<li>
静态方法不能被非静态方法覆盖；</li>
<li>
构造方法不允许声明为 static 的；</li>
<li>
局部变量不能使用static修饰。</li>
</ul>
<br>
静态方法举例：
<pre class="java">
public class Demo {
    static int sum(int x, int y){
        return x + y;
    }

    public static void main(String[] args) {
        int sum = Demo.sum(10, 10);
        System.out.println("10+10=" + sum);
    }
}</pre>
运行结果：<br>
10+10=20<br>
<br>
static 方法不需它所属的类的任何实例就会被调用，因此没有 this 值，不能访问实例变量，否则会引起编译错误。<br>
<br>
注意：实例变量只能通过对象来访问，不能通过类访问。<br>
<h2>
静态初始器（静态块）</h2>
块是由大括号包围的一段代码。静态初始器(Static Initializer)是一个存在于类中、方法外面的静态块。静态初始器仅仅在类装载的时候（第一次使用类的时候）执行一次，往往用来初始化静态变量。<br>
<br>
示例代码：
<pre class="java">
public class Demo {
    public static int i;
    static{
        i = 10;
        System.out.println("Now in static block.");
    }
    public void test() {
        System.out.println("test method: i=" + i);
    }

    public static void main(String[] args) {
        System.out.println("Demo.i=" + Demo.i);
        new Demo().test();
    }
}</pre>
运行结果是：<br>
Now in static block.<br>
Demo.i=10<br>
test method: i=10<br>
<h2>
静态导入</h2>
静态导入是 Java 5 的新增特性，用来导入类的静态变量和静态方法。<br>
<br>
一般我们导入类都这样写：
<pre class="java">
import packageName.className;  // 导入某个特定的类</pre>
或
<pre class="java">
import packageName.*;  // 导入包中的所有类</pre>
<br>
而静态导入可以这样写：
<pre class="java">
import static packageName.className.methonName;  // 导入某个特定的静态方法</pre>
或
<pre class="java">
import static packageName.className.*;  // 导入类中的所有静态成员</pre>
<br>
导入后，可以在当前类中直接用方法名调用静态方法，不必再用 className.methodName 来访问。<br>
<br>
对于使用频繁的静态变量和静态方法，可以将其静态导入。静态导入的好处是可以简化一些操作，例如输出语句 System.out.println(); 中的 out 就是 System 类的静态变量，可以通过 import static java.lang.System.*; 将其导入，下次直接调用 out.println() 就可以了。<br>
<br>
请看下面的代码：
<pre class="java">
import static java.lang.System.*;
import static java.lang.Math.random;
public class Demo {
    public static void main(String[] args) {
        out.println("产生的一个随机数：" + random());
    }
}</pre>
运行结果：<br>
产生的一个随机数：0.05800891549018705</div>

http://www.weixueyuan.net/view/6003.html
<h1>Java final关键字：阻止继承和多态</h1>
<div id="art-body">在 Java 中，声明类、变量和方法时，可使用关键字 final 来修饰。final 所修饰的数据具有“终态”的特征，表示“最终的”意思。具体规定如下：
<ul>
<li>
final 修饰的类不能被继承。</li>
<li>
final 修饰的方法不能被子类重写。</li>
<li>
final 修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次。</li>
<li>
final 修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有 一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。</li>
<li>
final 修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。</li>
</ul>
<br>
final 一般用于修饰那些通用性的功能、实现方式或取值不能随意被改变的数据，以避免被误用，例如实现数学三角方法、幂运算等功能的方法，以及数学常量π=3.141593、e=2.71828 等。<br>
<br>
事实上，为确保终态性，提供了上述方法和常量的 java.lang.Math 类也已被定义为final 的。<br>
<br>
需要注意的是，如果将引用类型（任何类的类型）的变量标记为 final，那么该变量不能指向任何其它对象。但可以改变对象的内容，因为只有引用本身是 final 的。<br>
<br>
如果变量被标记为 final，其结果是使它成为常数。想改变 final 变量的值会导致一个编译错误。下面是一个正确定义 final 变量的例子：
<pre class="java">
public final int MAX_ARRAY_SIZE = 25;  // 常量名一般大写</pre>
常量因为有 final 修饰，所以不能被继承。<br>
<br>
请看下面的代码：
<pre class="java">
public final class Demo{
    public static final int TOTAL_NUMBER = 5;
    public int id;
    public Demo() {
        // 非法，对final变量TOTAL_NUMBER进行二次赋值了
        // 因为++TOTAL_NUMBER相当于 TOTAL_NUMBER=TOTAL_NUMBER+1
        id = ++TOTAL_NUMBER;
    }
    public static void main(String[] args) {
        final Demo t = new Demo();
        final int i = 10;
        final int j;
        j = 20;
        j = 30;  // 非法，对final变量进行二次赋值
    }
}</pre>
<br>
final 也可以用来修饰类（放在 class 关键字前面），阻止该类再派生出子类，例如 Java.lang.String 就是一个 final 类。这样做是出于安全原因，因为要保证一旦有字符串的引用，就必须是类 String 的字符串，而不是某个其它类的字符串（String 类可能被恶意继承并篡改）。<br>
<br>
方法也可以被 final 修饰，被 final 修饰的方法不能被覆盖；变量也可以被 final 修饰，被 final 修饰的变量在创建对象以后就不允许改变它们的值了。一旦将一个类声明为 final，那么该类包含的方法也将被隐式地声明为 final，但是变量不是。<br>
<br>
被 final 修饰的方法为静态绑定，不会产生多态（动态绑定），程序在运行时不需要再检索方法表，能够提高代码的执行效率。在Java中，被 static 或 private 修饰的方法会被隐式的声明为 final，因为动态绑定没有意义。<br>
<br>
由于动态绑定会消耗资源并且很多时候没有必要，所以有一些程序员认为：除非有足够的理由使用多态性，否则应该将所有的方法都用 final 修饰。<br>
<br>
这样的认识未免有些偏激，因为 JVM 中的即时编译器能够实时监控程序的运行信息，可以准确的知道类之间的继承关系。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程为称为内联(inlining)。例如，内联调用 e.getName() 将被替换为访问 e.name 变量。这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略，所以，这被视为不受欢迎的。然而，如果 getName() 在另外一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。<br>
</div>

http://www.weixueyuan.net/view/6004.html
<h1>Java Object类</h1>
<div id="art-body">Object 类位于 java.lang 包中，是所有 Java 类的祖先，Java 中的每个类都由它扩展而来。<br>
<br>
定义Java类时如果没有显示的指明父类，那么就默认继承了 Object 类。例如：
<pre class="java">
public class Demo{
    // ...
}</pre>
实际上是下面代码的简写形式：
<pre class="java">
public class Demo extends Object{
    // ...
}</pre>
在Java中，只有基本类型不是对象，例如数值、字符和布尔型的值都不是对象，所有的数组类型，不管是对象数组还是基本类型数组都是继承自 Object 类。<br>
<br>
Object 类定义了一些有用的方法，由于是根类，这些方法在其他类中都存在，一般是进行了重载或覆盖，实现了各自的具体功能。
<h2>
equals() 方法</h2>
Object 类中的 equals() 方法用来检测一个对象是否等价于另外一个对象，语法为：<br>
    public boolean equals(Object obj)<br>
例如：
<pre class="java">
obj1.equals(obj2);</pre>
在Java中，数据等价的基本含义是指两个数据的值相等。在通过 equals() 和“==”进行比较的时候，引用类型数据比较的是引用，即内存地址，基本数据类型比较的是值。<br>
<br>
注意：
<ul>
<li>
equals()方法只能比较引用类型，“==”可以比较引用类型及基本类型。</li>
<li>
当用 equals() 方法进行比较时，对类 File、String、Date 及包装类来说，是比较类型及内容而不考虑引用的是否是同一个实例。</li>
<li>
用“==”进行比较时，符号两边的数据类型必须一致（可自动转换的数据类型除外），否则编译出错，而用 equals 方法比较的两个数据只要都是引用类型即可。</li>
</ul>
<h2>
hashCode() 方法</h2>
散列码(hashCode)是按照一定的算法由对象得到的一个数值，散列码没有规律。如果 x 和 y 是不同的对象，x.hashCode() 与 y.hashCode() 基本上不会相同。<br>
<br>
hashCode() 方法主要用来在集合中实现快速查找等操作，也可以用于对象的比较。<br>
<br>
在 Java 中，对 hashCode 的规定如下：
<ul>
<li>
在同一个应用程序执行期间，对同一个对象调用 hashCode()，必须返回相同的整数结果——前提是 equals() 所比较的信息都不曾被改动过。至于同一个应用程序在不同执行期所得的调用结果，无需一致。</li>
<li>
如果两个对象被 equals() 方法视为相等，那么对这两个对象调用 hashCode() 必须获得相同的整数结果。</li>
<li>
如果两个对象被 equals() 方法视为不相等，那么对这两个对象调用 hashCode() 不必产生不同的整数结果。然而程序员应该意识到，对不同对象产生不同的整数结果，有可能提升hashTable（后面会学到，集合框架中的一个类）的效率。</li>
</ul>
<br>
简单地说：如果两个对象相同，那么它们的 hashCode 值一定要相同；如果两个对象的 hashCode 值相同，它们并不一定相同。在 Java 规范里面规定，一般是覆盖 equals() 方法应该连带覆盖 hashCode() 方法。
<h2>
toString() 方法</h2>
toString() 方法是 Object 类中定义的另一个重要方法，是对象的字符串表现形式，语法为：<br>
    public String toString()<br>
返回值是 String 类型，用于描述当前对象的有关信息。Object 类中实现的 toString() 方法是返回当前对象的类型和内存地址信息，但在一些子类（如 String、Date 等）中进行了 重写，也可以根据需要在用户自定义类型中重写 toString() 方法，以返回更适用的信息。<br>
<br>
除显式调用对象的 toString() 方法外，在进行 String 与其它类型数据的连接操作时，会自动调用 toString() 方法。<br>
<br>
以上几种方法，在Java中是经常用到的，这里仅作简单介绍，让大家对Object类和其他类有所了解，详细说明请参考 Java API 文档。</div>

http://www.weixueyuan.net/view/6051.html