
<h1>Java输入输出(IO)和流的基本概念</h1>
<div id="art-body">输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，如从键盘上读取数据，从本地或网络上的文件读取数据或写入数据等。通过输入和输出操作可以从外界接收信息，或者是把信息传递给外界。Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。
<h2>
Java流的概念</h2>
流（Stream）是指在计算机的输入输出操作中各部件之间的数据流动。<span style="color:#b22222;">按照数据的传输方向，流可分为输入流与输出流。</span>Java语言里的流序列中的数据既可以是未经加工的原始二进制数据，也可以是经过一定编码处理后符合某种特定格式的数据。<br>
<br>
<strong>1．输入输出流</strong><br>
<span style="color:#b22222;">在Java中，把不同类型的输入输出源抽象为流，其中输入和输出的数据称为数据流（Data Stream）。</span>数据流是Java程序发送和接收数据的一个通道，数据流中包括输入流（Input Stream）和输出流（Output Stream）。通常应用程序中使用输入流读出数据，输出流写入数据。 流式输入、输出的特点是数据的获取和发送均沿数据序列顺序进行。相对于程序来说，输出流是往存储介质或数据通道写入数据，而输入流是从存储介质或数据通道中读取数据，一般来说关于流的特性有下面几点：
<ul>
<li>
先进先出，最先写入输出流的数据最先被输入流读取到。</li>
<li>
顺序存取，可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。</li>
<li>
只读或只写，每个流只能是输入流或输出流的一种，不能同时具备两个功能，在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。</li>
</ul>
<br>
<strong>2．缓冲流</strong><br>
为了提高数据的传输效率，引入了缓冲流（Buffered Stream）的概念，<span style="color:#b22222;">即为一个流配备一个缓冲区（Buffer），一个缓冲区就是专门用于传送数据的一块内存</span>。<br>
<br>
当向一个缓冲流写入数据时，系统将数据发送到缓冲区，而不是直接发送到外部设备。缓冲区自动记录数据，当缓冲区满时，系统将数据全部发送到相应的外部设备。当从一个缓冲流中读取数据时，系统实际是从缓冲区中读取数据，当缓冲区为空时，系统就会从相关外部设备自动读取数据，并读取尽可能多的数据填满缓冲区。 使用数据流来处理输入输出的目的是使程序的输入输出操作独立于相关设备，由于程序不需关注具体设备实现的细节（具体细节由系统处理），所以对于各种输入输出设备，只要针对流做处理即可，不需修改源程序，从而增强了程序的可移植性。
<h2>
I/O流类概述</h2>
为了方便流的处理，Java语言提供了<span style="color:#b22222;">java.io</span>包，在该包中的每一个类都代表了一种特定的输入或输出流。为了使用这些流类，编程时需要引入这个包。 <span style="color:#b22222;">Java提供了两种类型的输入输出流：一种是面向字节的流，数据的处理以字节为基本单位；另一种是面向字符的流，用于字符数据的处理。</span>字节流（Byte Stream）每次读写8位二进制数，也称为二进制字节流或位流。字符流一次读写16位二进制数，并将其做一个字符而不是二进制位来处理。需要注意的是，为满足字符的国际化表示，Java语言的字符编码采用的是16位的Unicode码，而普通文本文件中采用的是8位ASCⅡ码。<br>
<br>
java.io中类的层次结构如图10-1所示。<br>
<div style="text-align: center; ">
<img alt="图10-1 java.io包的顶级层次结构图" src="http://www.weixueyuan.net/uploads/allimg/130222/8-130222204U5941.jpg" style="width: 371px; height: 196px; "><br>
图10-1 java.io包的顶级层次结构图</div>
<br>
针对一些频繁的设备交互，Java语言系统预定了3个可以直接使用的流对象，分别是：
<ul>
<li>
System.in（标准输入），通常代表键盘输入。</li>
<li>
System.out（标准输出）：通常写往显示器。</li>
<li>
System.err（标准错误输出）：通常写往显示器。</li>
</ul>
在Java语言中使用字节流和字符流的步骤基本相同，以输入流为例，首先创建一个与数据源相关的流对象，然后利用流对象的方法从流输入数据，最后执行close()方法关闭流。</div>

http://www.weixueyuan.net/view/6042.html
<h1>Java中面向字符的输入流</h1>
<div id="art-body">字符流是针对字符数据的特点进行过优化的，因而提供一些面向字符的有用特性，字符流的源或目标通常是文本文件。 Reader和Writer是java.io包中所有字符流的父类。由于它们都是抽象类，所以应使用它们的子类来创建实体对象，利用对象来处理相关的读写操作。Reader和Writer的子类又可以分为两大类：一类用来从数据源读入数据或往目的地写出数据（称为节点流），另一类对数据执行某种处理（称为处理流）。<br>
<br>
<span style="color:#b22222;">面向字符的输入流类都是Reader的子类</span>，其类层次结构如图10-2所示。
<div style="text-align: center; ">
<img alt="图10-2 Reader的类层次结构图" src="http://www.weixueyuan.net/uploads/allimg/130222/8-130222205I61F.jpg" style="width: 446px; height: 218px; "><br>
图10-2 Reader的类层次结构图</div>
<br>
表 10-1 列出了 Reader 的主要子类及说明。<br>
<table>
<caption>
表 10-1 Reader 的主要子类</caption>
<tbody>
<tr>
<th>
类名</th>
<th>
功能描述</th>
</tr>
<tr>
<td>
CharArrayReader</td>
<td>
从字符数组读取的输入流</td>
</tr>
<tr>
<td>
BufferedReader</td>
<td>
缓冲输入字符流</td>
</tr>
<tr>
<td>
PipedReader</td>
<td>
输入管道</td>
</tr>
<tr>
<td>
InputStreamReader</td>
<td>
将字节转换到字符的输入流</td>
</tr>
<tr>
<td>
FilterReader</td>
<td>
过滤输入流</td>
</tr>
<tr>
<td>
StringReader</td>
<td>
从字符串读取的输入流</td>
</tr>
<tr>
<td>
LineNumberReader</td>
<td>
为输入数据附加行号</td>
</tr>
<tr>
<td>
PushbackReader</td>
<td>
返回一个字符并把此字节放回输入流</td>
</tr>
<tr>
<td>
FileReader</td>
<td>
从文件读取的输入流</td>
</tr>
</tbody>
</table>
<br>
Reader 所提供的方法如表 10-2 所示，可以利用这些方法来获得流内的位数据。<br>
<table>
<caption>
表 10-2 Reader 的常用方法</caption>
<tbody>
<tr>
<th>
方法</th>
<th>
功能描述</th>
</tr>
<tr>
<td>
void close()</td>
<td>
关闭输入流</td>
</tr>
<tr>
<td>
void mark()</td>
<td>
标记输入流的当前位置</td>
</tr>
<tr>
<td>
boolean markSupported()</td>
<td>
测试输入流是否支持 mark</td>
</tr>
<tr>
<td>
int read()</td>
<td>
从输入流中读取一个字符</td>
</tr>
<tr>
<td>
int read(char[] ch)</td>
<td>
从输入流中读取字符数组</td>
</tr>
<tr>
<td>
int read(char[] ch, int off, int len)</td>
<td>
从输入流中读 len 长的字符到 ch 内</td>
</tr>
<tr>
<td>
boolean ready()</td>
<td>
测试流是否可以读取</td>
</tr>
<tr>
<td>
void reset()</td>
<td>
重定位输入流</td>
</tr>
<tr>
<td>
long skip(long n)</td>
<td>
跳过流内的 n 个字符</td>
</tr>
</tbody>
</table>
<h2>
使用 FileReader 类读取文件</h2>
FileReader 类是 Reader 子类 InputStreamReader 类的子类，因此 FileReader 类既可以使用Reader 类的方法也可以使用 InputStreamReader 类的方法来创建对象。<br>
<br>
在使用 FileReader 类读取文件时，必须先调用 FileReader()构造方法创建 FileReader 类的对象，再调用 read()方法。FileReader 构造方法的格式为：<br>
    <span style="color:#b22222;">public FileReader(String name);  //根据文件名创建一个可读取的输入流对象</span><br>
<br>
【例 10-1】利用 FileReader 类读取纯文本文件的内容（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/10-1.txt" target="_blank">查看源代码</a>）。<br>
<br>
运行结果如图 10-3 所示：<br>
<div style="text-align: center; ">
<img alt="" src="http://www.weixueyuan.net/uploads/allimg/130222/8-130222212005X5.jpg" style="width: 366px; height: 223px; "><br>
图 10-3  例 10_1 运行结果（输出内容为文件ep10_1.txt的内容）</div>
<br>
<span style="color:#b22222;">需要注意的是，Java 把一个汉字或英文字母作为一个字符对待，回车或换行作为两个字符对待。</span>
<h2>
使用 BufferedReader 类读取文件</h2>
BufferedReader 类是用来读取缓冲区中的数据。使用时必须创建 FileReader 类对象，再以该对象为参数创建 BufferedReader 类的对象。BufferedReader 类有两个构造方法，其格式为：<br>
    <span style="color:#b22222;">public BufferedReader(Reader in);  //创建缓冲区字符输入流<br>
    public BufferedReader(Reader in,int size);  //创建输入流并设置缓冲区大小</span><br>
<br>
【例 10-2】利用 BufferedReader 类读取纯文本文件的内容（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/10-2.txt" target="_blank">查看源代码</a>）。<br>
<br>
运行结果如图 10-4 所示：<br>
<div style="text-align: center; ">
<img alt="" src="http://www.weixueyuan.net/uploads/allimg/130222/8-130222212425P5.jpg" style="width: 366px; height: 206px; "><br>
图 10-4  例 10_2 运行结果</div>
<br>
需要注意的是，执行 read()或 write()方法时，可能由于 IO 错误，系统抛出 IOException 异常，需要将执行读写操作的语句包括在 try 块中，并通过相应的 catch 块来处理可能产生的异常。<br>
</div>

http://www.weixueyuan.net/view/6043.html
<h1>Java面向字符的输出流</h1>
<div id="art-body">面向字符的输出流都是类 Writer 的子类，其类层次结构如图 10-5 所示。
<div style="text-align: center; ">
<img alt="图10-5 Writer的类层次结构图" src="http://www.weixueyuan.net/uploads/allimg/130222/8-130222220415504.jpg" style="width: 445px; height: 255px; "><br>
图10-5 Writer的类层次结构图</div>
<br>
表 10-3 列出了 Writer 的主要子类及说明。<br>
<table>
<caption>
表 10-3 Writer 的主要子类</caption>
<tbody>
<tr>
<th>
类名</th>
<th>
功能说明</th>
</tr>
<tr>
<td>
CharArrayWriter</td>
<td>
写到字符数组的输出流</td>
</tr>
<tr>
<td>
BufferedWriter</td>
<td>
缓冲输出字符流</td>
</tr>
<tr>
<td>
PipedWriter</td>
<td>
输出管道</td>
</tr>
<tr>
<td>
OutputStreamWriter</td>
<td>
转换字符到字节的输出流</td>
</tr>
<tr>
<td>
FilterWriter</td>
<td>
过滤输出流</td>
</tr>
<tr>
<td>
StringWriter</td>
<td>
输出到字符串的输出流</td>
</tr>
<tr>
<td>
PrintWriter</td>
<td>
包含 print()和 println()的输出流</td>
</tr>
<tr>
<td>
FileWriter</td>
<td>
输出到文件的输出流</td>
</tr>
</tbody>
</table>
<br>
Writer 所提供的方法如表 10-4 所示。<br>
<table>
<caption>
表 10-4 Writer 的常用方法</caption>
<tbody>
<tr>
<th>
方法</th>
<th>
功能描述</th>
</tr>
<tr>
<td>
void close()</td>
<td>
关闭输出流</td>
</tr>
<tr>
<td>
void flush()</td>
<td>
将缓冲区中的数据写到文件中</td>
</tr>
<tr>
<td>
void writer(int c)</td>
<td>
将单一字符 c 输出到流中</td>
</tr>
<tr>
<td>
void writer(String str)</td>
<td>
将字符串 str 输出到流中</td>
</tr>
<tr>
<td>
void writer(char[] ch)</td>
<td>
将字符数组 ch 输出到流</td>
</tr>
<tr>
<td>
void writer(char[] ch, int offset, int length)</td>
<td>
将一个数组内自 offset 起到 length 长的字符输出到流</td>
</tr>
</tbody>
</table>
<h2>
使用 FileWriter 类写入文件</h2>
FileWriter 类是 Writer 子类 OutputStreamWriter 类的子类，因此 FileWriter 类既可以使用 Writer类的方法也可以使用 OutputStreamWriter 类的方法来创建对象。<br>
<br>
在使用 FileWriter 类写入文件时，必须先调用 FileWriter()构造方法创建 FileWriter 类的对象，再调用 writer()方法。FileWriter 构造方法的格式为：<br>
    <span style="color:#b22222;">public FileWriter(String name);  //根据文件名创建一个可写入的输出流对象<br>
    public FileWriter(String name,Boolean a);  //a 为真，数据将追加在文件后面</span><br>
<br>
【例 10-3】利用 FileWriter 类将 ASCⅡ字符写入到文件中（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/10-3.txt" target="_blank">查看源代码</a>）。<br>
<br>
运行后程序后，打开 ep10_3.txt 文件，显示内容为：<br>
!"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}
<h2>
使用 BufferedWriter 类写入文件</h2>
BufferedWriter 类是用来将数据写入到缓冲区。使用时必须创建 FileWriter 类对象，再以该对象为参数创建 BufferedWriter 类的对象，最后需要用 flush()方法将缓冲区清空。BufferedWriter类有两个构造方法，其格式为：<br>
    <span style="color:#b22222;">public BufferedWriter(Writer out);  //创建缓冲区字符输出流<br>
    public BufferedWriter(Writer out,int size);  //创建输出流并设置缓冲区大小</span><br>
<br>
【例 10-4】利用 BufferedWriter 类进行文件复制（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/10-4.txt" target="_blank">查看源代码</a>）。<br>
<br>
需要注意的是，调用 out 对象的 write()方法写入数据时，不会写入回车，因此需要使用newLine()方法在每行数据后加入回车，以保证目标文件与源文件相一致。<br>
</div>

http://www.weixueyuan.net/view/6044.html
<h1>Java中面向字节的输入输出流</h1>
<div id="art-body">字节流以字节为传输单位，用来读写8位的数据，除了能够处理纯文本文件之外，还能用来处理二进制文件的数据。 <span style="color:#b22222;">InputStream类和OutputStream类是所有字节流的父类。</span>
<h2>
InputStream类</h2>
面向字节的输入流都是InputStream类的子类，其类层次结构如图10-6所示。
<div style="text-align: center; ">
<img alt="" src="http://www.weixueyuan.net/uploads/allimg/130222/8-1302222326024a.png" style="width: 491px; height: 218px; "><br>
图10-6 InputStream的类层次结构图</div>
<br>
表 10-5 列出了 InputStream 的主要子类及说明。<br>
<table>
<caption>
表 10-5 InputStream 的主要子类</caption>
<tbody>
<tr>
<th>
类名</th>
<th>
功能描述</th>
</tr>
<tr>
<td>
FileInputStream</td>
<td>
从文件中读取的输入流</td>
</tr>
<tr>
<td>
PipedInputStream</td>
<td>
输入管道</td>
</tr>
<tr>
<td>
FilterInputStream</td>
<td>
过滤输入流</td>
</tr>
<tr>
<td>
ByteArrayInputStream</td>
<td>
从字节数组读取的输入流</td>
</tr>
<tr>
<td>
SequenceInputStream</td>
<td>
两个或多个输入流的联合输入流，按顺序读取</td>
</tr>
<tr>
<td>
ObjectInputStream</td>
<td>
对象的输入流</td>
</tr>
<tr>
<td>
LineNumberInputStream</td>
<td>
为文本文件输入流附加行号</td>
</tr>
<tr>
<td>
DataInputStream</td>
<td>
包含读取 Java 标准数据类型方法的输入流</td>
</tr>
<tr>
<td>
BufferedInputStream</td>
<td>
缓冲输入流</td>
</tr>
<tr>
<td>
PushbackInputStream</td>
<td>
返回一个字节并把此字节放回输入流</td>
</tr>
</tbody>
</table>
<br>
InputStream 流类中包含一套所有输入都需要的方法，可以完成最基本的从输入流读入数据的功能。表 10-6 列出了其中常用的方法及说明。<br>
<table>
<caption>
表 10-6 InputStream 的常用方法</caption>
<tbody>
<tr>
<th>
方法</th>
<th>
功能描述</th>
</tr>
<tr>
<td>
void close()</td>
<td>
关闭输入流</td>
</tr>
<tr>
<td>
void mark()</td>
<td>
标记输入流的当前位置</td>
</tr>
<tr>
<td>
void reset()</td>
<td>
将读取位置返回到标记处</td>
</tr>
<tr>
<td>
int read()</td>
<td>
从输入流中当前位置读入一个字节的二进制数据，以此数据为低位字节，补足16位的整型量（0~255）后返回，若输入流中当前位置没有数据，则返回-1</td>
</tr>
<tr>
<td>
int read(byte b[])</td>
<td>
从输入流中的当前位置连续读入多个字节保存在数组中，并返回所读取的字节数</td>
</tr>
<tr>
<td>
int read(byte b[], int off, int len)</td>
<td>
从输入流中当前位置连续读len长的字节，从数组第off+1个元素位置处开始存放，并返回所读取的字节数</td>
</tr>
<tr>
<td>
int available()</td>
<td>
返回输入流中可以读取的字节数</td>
</tr>
<tr>
<td>
long skip(long n)</td>
<td>
略过n个字节</td>
</tr>
<tr>
<td>
long skip(long n)</td>
<td>
跳过流内的n个字符</td>
</tr>
<tr>
<td>
boolean markSupported()</td>
<td>
测试输入数据流是否支持标记</td>
</tr>
</tbody>
</table>
<h2>
OutputStream类</h2>
面向字节的输出流都是OutputStream类的子类，其类层次结构如图10-7所示。
<div style="text-align: center; ">
<img alt="图10-7 OutputStream的类层次结构图" src="http://www.weixueyuan.net/uploads/allimg/130222/8-1302222312562N.jpg" style="width: 501px; height: 177px; "><br>
图10-7 OutputStream的类层次结构图</div>
<br>
10-7列出了OutputStream的主要子类及说明。 <br>
<table>
<caption>
表10-7 OutputStream的主要子类</caption>
<tbody>
<tr>
<th>
类名</th>
<th>
功能描述</th>
</tr>
<tr>
<td>
FileOutputStream</td>
<td>
写入文件的输出流</td>
</tr>
<tr>
<td>
PipedOutputStream</td>
<td>
输出管道</td>
</tr>
<tr>
<td>
FilterOutputStream</td>
<td>
过滤输出流</td>
</tr>
<tr>
<td>
ByteArrayOutputStream</td>
<td>
写入字节数组的输出流</td>
</tr>
<tr>
<td>
ObjectOutputStream</td>
<td>
对象的输出流</td>
</tr>
<tr>
<td>
DataOutputStream</td>
<td>
包含写Java标准数据类型方法的输出流</td>
</tr>
<tr>
<td>
BufferedOutputStream</td>
<td>
缓冲输出流</td>
</tr>
<tr>
<td>
PrintStream</td>
<td>
包含print()和println()的输出流</td>
</tr>
</tbody>
</table>
<br>
OutputStream流类中包含一套所有输出都需要的方法，可以完成最基本的向输出流写入数据的功能。表10-8列出了其中常用的方法及说明。 <br>
<table>
<caption>
表10-8 OutputStream的常用方法</caption>
<tbody>
<tr>
<th>
方法</th>
<th>
功能描述</th>
</tr>
<tr>
<td>
void close()</td>
<td>
关闭输出流</td>
</tr>
<tr>
<td>
void flush()</td>
<td>
强制清空缓冲区并执行向外设输出数据</td>
</tr>
<tr>
<td>
void write(int b)</td>
<td>
将参数b的低位字节写入到输出流</td>
</tr>
<tr>
<td>
void write(byte b[])</td>
<td>
按顺序将数组b[]中的全部字节写入到输出流</td>
</tr>
<tr>
<td>
void write(byte b[], int off, int len)</td>
<td>
按顺序将数组b[]中第off+1个元素开始的len个数据写入到输出流</td>
</tr>
</tbody>
</table>
<br>
由于InputStream和OutputStream都是抽象类，所以在程序中创建的输入流对象一般是它们某个子类的对象，通过调用对象继承的read()和write()方法就可实现对相应外设的输入输出操作。</div>

http://www.weixueyuan.net/view/6045.html
<h1>Java面向字节流的应用</h1>
<div id="art-body"><h2>
文件输入输出流</h2>
<span style="color:#b22222;">文件输入输出流 FileInputStream 和 FileOutputStream 负责完成对本地磁盘文件的顺序输入输出操作。</span><br>
<br>
【例 10-5】通过程序创建一个文件，从键盘输入字符，当遇到字符“#”时结束，在屏幕上显示该文件的所有内容（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/10-5.txt" target="_blank">查看源代码</a>）。<br>
<br>
运行后在程序目录建立一个名称为 ep10_5 的文件，运行结果如图 10-8 所示：
<div style="text-align: center; ">
<img alt="图 10-8   例 10_5 运行结果 " src="http://www.weixueyuan.net/uploads/allimg/130222/8-130222233111D3.jpg" style="width: 279px; height: 159px; "><br>
图 10-8  例 10_5 运行结果</div>
<br>
FileDescriptor 是 java.io 中的一个类，该类不能实例化，其中包含三个静态成员：in、out 和err，分别对应于标准输入流、标准输出流和标准错误流，利用它们可以在标准输入输出流上建立文件输入输出流，实现键盘输入或屏幕输出操作。<br>
<br>
【例 10-6】实现对二进制图形文件（.gif）的备份（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/10-6.txt" target="_blank">查看源代码</a>）。<br>
<br>
运行后在程序目录备份了一个名称为 ep10_6_a.gif 的文件，运行结果如图 10-9 所示：
<div style="text-align: center; ">
<img alt="" src="http://www.weixueyuan.net/uploads/allimg/130222/8-130222233354Y7.png" style="width: 198px; height: 150px; "><br>
图 10-9  例 10_6 运行结果</div>
<h2>
过滤流</h2>
FilterInputStream 和 FileOutputStream 是 InputStream 和 OutputStream 的直接子类，分别实现了在数据的读、写操作的同时能对所传输的数据做指定类型或格式的转换，即可实现对二进制字节数据的理解和编码转换。<br>
<br>
常用的两个过滤流是数据输入流 DataInputStream 和数据输出流 DataOutputStream。其构造方法为：<br>
    <span style="color:#b22222;">DataInputStream(InputStream in);  //创建新输入流，从指定的输入流 in 读数据<br>
    DataOutputStream(OutputStream out);  //创建新输出流，向指定的输出流 out 写数据</span><br>
<br>
由于 DataInputStream 和 DataOutputStream 分别实现了 DataInput 和 DataOutput 两个接口（这两个接口规定了基本类型数据的输入输出方法）中定义的独立于具体机器的带格式的读写操作，从而实现了对不同类型数据的读写。由构造方法可以看出，输入输出流分别作为数据输入输出流的构造方法参数，即作为过滤流必须与相应的数据流相连。<br>
<br>
DataInputStream 和 DataOutputStream 类提供了很多个针对不同类型数据的读写方法，具体内容读者可参看 Java 的帮助文档。<br>
<br>
【例 10-7】将三个 int 型数字 100，0，-100 写入数据文件 ep10_6.dat 中（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/10-7.txt" target="_blank">查看源代码</a>）。<br>
<br>
运行后在程序目录中生成数据文件 ep10_7.dat，用文本编辑器打开后发现内容为二进制的：<br>
00 00 00 64 00 00 00 00 FF FF FF 9C。<br>
<br>
【例 10-8】读取数据文件 ep10_6.dat 中的三个 int 型数字，求和并显示（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/10-8.txt" target="_blank">查看源代码</a>）。<br>
<br>
运行结果：<br>
三个数的和为：0<br>
<br>
readInt 方法可以从输入输出流中读入 4 个字节并将其作为 int 型数据直接参与运算。由于已经知道文件中有 3 个数据，所以可以使用 3 个读入语句，但若只知道文件中是 int 型数据而不知道数据的个数时该怎么办呢？因为 DataInputStream 的读入操作如遇到文件结尾就会抛出 EOFException 异常，所以可将读操作放入 try 中。<br>
try{<br>
    while(true)<br>
    sum+=a.readInt();<br>
}<br>
catch(EOFException e){<br>
    System.out.pritnln("三个数的和为："+sum);<br>
    a.close();<br>
}<br>
EOFException 是 IOException 的子类，只有文件结束异常时才会被捕捉到，但如果没有读到文件结尾，在读取过程中出现异常就属于 IOException。<br>
<br>
【例 10-9】从键盘输入一个整数，求该数的各位数字之和（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/10-9.txt" target="_blank">查看源代码</a>）。<br>
<br>
运行结果：<br>
请输入一个整数：26<br>
842403082 的各位数字之和=31<br>
<br>
需要注意的是，输入的数据 26 为变成了 842403082，原因在于输入数据不符合基本类型数据的格式，从键盘提供的数据是字符的字节码表示方式，若输入 26，只代表 2 和 6 两个字符的字节数据，而不是代表整数 26 的字节码。<br>
<br>
若要从键盘得到整数需要先读取字符串，再利用其他方法将字符串转化为整数。
<h2>
标准输入输出</h2>
System.in、System.out、System.err 这 3 个标准输入输流对象定义在 java.lang.System 包中，这 3 个对象在 Java 源程序编译时会被自动加载。
<ol>
<li>
标准输入：标准输入 System.in 是 BufferedInputStream 类的对象，当程序需要从键盘上读入数据时，只需要调用 System.in 的 read()方法即可，该方法从键盘缓冲区读入一个字节的二进制数据，返回以此字节为低位字节，高位字节为 0 的整型数据。</li>
<li>
标准输出：标准输出 System.out 是打印输出流 PrintStream 类的对象。PrintStream 类是过滤输出流类 FilterOutputStream 的一个子类，其中定义了向屏幕输出不同类型数据的方法print()和 println()。</li>
<li>
标准错误输出：System.err 用于为用户显示错误信息，也是由 PrintStream 类派生出来的错误流。Err 流的作用是使 print()和 println()将信息输出到 err 流并显示在屏幕上，以方便用户使用和调试程序。</li>
</ol>
<br>
【例 10-10】输入一串字符显示出来，并显示 System.in 和 System.out 所属的类（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/10-10.txt" target="_blank">查看源代码</a>）。<br>
<br>
运行结果如图 10-10 所示：
<div style="text-align: center; ">
<img alt="图 10-10  例 10_10 运行结果" src="http://www.weixueyuan.net/uploads/allimg/130222/8-130222233615401.png" style="width: 398px; height: 215px; "><br>
图 10-10  例 10_10 运行结果</div>
<br>
需要注意的是，输入了 3 个字符按回车后，输出的结果显示为 5 个字符。这是由于 Java 中回车被当作两个字符，一个是 ASCⅡ为 13 的回车符，一个是值为 10 的换行符。程序中 getClass()和 ToString()是 Object 类的方法，作用分别是返回当前对象所对应的类和返回当前对象的字符串表示。<br>
</div>

http://www.weixueyuan.net/view/6046.html
<h1>Java中文件与目录管理</h1>
<div id="art-body">目录是管理文件的特殊机制，同类文件保存在同一个目录下不仅可以简化文件管理，而且还可以提高工作效率。Java 语言在 java.io 包中定义了一个 File 类专门用来管理磁盘文件和目录。<br>
<br>
每个 File 类对象表示一个磁盘文件或目录，其对象属性中包含了文件或目录的相关信息。通过调用 File 类提供的各种方法，能够创建、删除、重名名文件、判断文件的读写权限以及是否存在，设置和查询文件的最近修改时间等。不同操作系统具有不同的文件系统组织方式，通过使用 File 类对象，Java 程序可以用与平台无关的、统一的方式来处理文件和目录。
<h2>
创建 File 类的对象</h2>
创建 File 类对象需要给出其所对应的文件名或目录名，File 类的构造方法如表 10-9 所示。<br>
<table>
<caption>
表 10-9 File 类的构造方法</caption>
<tbody>
<tr>
<th>
构造方法</th>
<th>
功能描述</th>
</tr>
<tr>
<td>
public File(String path)</td>
<td>
指定与 File 对象关联的文件或目录名，path 可以包含路径及文件和目录名</td>
</tr>
<tr>
<td>
public File(String path, String name)</td>
<td>
以 path 为路径，以 name 为文件或目录名创建 File 对象</td>
</tr>
<tr>
<td>
public File(File dir, String name)</td>
<td>
用现有的 File 对象 dir 作为目录，以 name 作为文件或目录名创建 File 对象</td>
</tr>
<tr>
<td>
public File(UR ui)</td>
<td>
使用给定的统一资源定位符来定位文件</td>
</tr>
</tbody>
</table>
<br>
在使用 File 类的构造方法时，需要注意下面几点：<br>
（1）path 参数可以是绝对路径，也可以是相对路径，也可以是磁盘上的某个目录。<br>
（ 2）由于不同操作系统使用的目录分隔符不同，可以使用 System 类的一个静态变量System.dirSep，来实现在不同操作系统下都通用的路径。如：<br>
    "d:"+System.dirSep+"myjava"+System.dirSep+"file"
<h2>
获取属性和操作</h2>
借助 File 对象，可以获取文件和相关目录的属性信息并可以对其进行管理和操作。表 10-10列出了其常用的方法及说明。<br>
<table>
<caption>
表 10-10 File 的常用方法</caption>
<tbody>
<tr>
<th>
方法</th>
<th>
功能描述</th>
</tr>
<tr>
<td>
boolean canRead()</td>
<td>
如果文件可读，返回真，否则返回假</td>
</tr>
<tr>
<td>
boolean canWrite()</td>
<td>
如果文件可写，返回真，否则返回假</td>
</tr>
<tr>
<td>
boolean exists()</td>
<td>
判断文件或目录是否存在</td>
</tr>
<tr>
<td>
boolean createNewFile()</td>
<td>
若文件不存在，则创建指定名字的空文件，并返回真，若不存在返回假</td>
</tr>
<tr>
<td>
boolean isFile()</td>
<td>
判断对象是否代表有效文件</td>
</tr>
<tr>
<td>
boolean isDirectory()</td>
<td>
判断对象是否代表有效目录</td>
</tr>
<tr>
<td>
boolean equals(File f)</td>
<td>
比较两个文件或目录是否相同</td>
</tr>
<tr>
<td>
string getName()</td>
<td>
返回文件名或目录名的字符串</td>
</tr>
<tr>
<td>
string getPath()</td>
<td>
返回文件或目录路径的字符串</td>
</tr>
<tr>
<td>
long length()</td>
<td>
返回文件的字节数，若 File 对象代表目录，则返回 0</td>
</tr>
<tr>
<td>
long lastModified()</td>
<td>
返回文件或目录最近一次修改的时间</td>
</tr>
<tr>
<td>
String[] list()</td>
<td>
将目录中所有文件名保存在字符串数组中并返回，若 File 对象不是目录返回 null</td>
</tr>
<tr>
<td>
boolean delete()</td>
<td>
删除文件或目录，必须是空目录才能删除，删除成功返回真，否则返回假</td>
</tr>
<tr>
<td>
boolean mkdir()</td>
<td>
创建当前目录的子目录，成功返回真，否则返回假</td>
</tr>
<tr>
<td>
boolean renameTo(File newFile)</td>
<td>
将文件重命名为指定的文件名</td>
</tr>
</tbody>
</table>
<br>
【例 10-11】判断输入的绝对路径是代表一个文件或一个目录。若是文件输出此文件的绝对路径，并判断此文件的文件属性（是否可读写或隐藏）;若是目录则输出该目录下所有文件（不包括隐藏文件）（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/10-11.txt" target="_blank">查看源代码</a>）。<br>
<br>
运行结果如图 10-11 所示：
<div style="text-align: center; ">
<img alt="图 10-11  输入一个文件路径后例 10_11 的运行结果" src="http://www.weixueyuan.net/uploads/allimg/130223/8-130223002415423.png" style="width: 296px; height: 232px; "><br>
图 10-11  输入一个文件路径后例 10_11 的运行结果</div>
</div>

http://www.weixueyuan.net/view/6047.html
<h1>Java中文件的随机读写</h1>
<div id="art-body">Java.io 包提供了 RandomAccessFile 类用于随机文件的创建和访问。使用这个类，可以跳转到文件的任意位置读写数据。程序可以在随机文件中插入数据，而不会破坏该文件的其他数据。此外，程序也可以更新或删除先前存储的数据，而不用重写整个文件。<br>
<br>
RandomAccessFile类是Object类的直接子类，包含两个主要的构造方法用来创 建RandomAccessFile 的对象，如表 10-11 所示。<br>
<table>
<caption>
表 10-11 RandomAccessFile 类的构造方法</caption>
<tbody>
<tr>
<th>
构造方法</th>
<th>
功能描述</th>
</tr>
<tr>
<td>
public RandomAccessFile(String name, String mode)</td>
<td>
指定随机文件流对象所对应的文件名，以 mode 表示对文件的访问模式</td>
</tr>
<tr>
<td>
public RandomAccessFile (File file, String mode)</td>
<td>
以 file 指定随机文件流对象所对应的文件名，以 mode 表示访问模式</td>
</tr>
</tbody>
</table>
<br>
<span style="color:#b22222;">需要注意的是，mode 表示所创建的随机读写文件的操作状态</span>，其取值包括：
<ul>
<li>
r：表示以只读方式打开文件。</li>
<li>
rw：表示以读写方式打开文件，使用该模式只用一个对象即可同时实现读写操作。</li>
</ul>
<br>
表 10-12 列出了 RandowAccessFile 类常用的方法及说明。<br>
<table>
<caption>
表 10-12 RandowAccessFile 的常用方法</caption>
<tbody>
<tr>
<th>
方法</th>
<th>
功能描述</th>
</tr>
<tr>
<td>
long length()</td>
<td>
返回文件长度</td>
</tr>
<tr>
<td>
void seek(long pos)</td>
<td>
移动文件位置指示器，pos 指定从文件开头的偏离字节数</td>
</tr>
<tr>
<td>
int skipBytes(int n)</td>
<td>
跳过 n 个字节，返回数为实际跳过的字节数</td>
</tr>
<tr>
<td>
int read()</td>
<td>
从文件中读取一个字节，字节的高 24 位为 0，若遇到文件结尾，返回-1</td>
</tr>
<tr>
<td>
final byte readByte()</td>
<td>
从文件中读取带符号的字节值</td>
</tr>
<tr>
<td>
final char readChar()</td>
<td>
从文件中读取一个 Unicode 字符</td>
</tr>
<tr>
<td>
final void writeChar(inte c)</td>
<td>
写入一个字符，两个字节</td>
</tr>
</tbody>
</table>
<br>
【例 10-12】模仿系统日志，将数据写入到文件尾部。<br>
//********** ep10_12.java **********<br>
import java.io.*;<br>
class ep10_12{<br>
    public static void main(String args[]) throws IOException{<br>
        try{<br>
            BufferedReader in=new BufferedReader(new InputStreamReader(System.in));<br>
            String s=in.readLine();<br>
            RandomAccessFile myFile=new RandomAccessFile("ep10_12.log","rw");<br>
            myFile.seek(myFile.length());  //移动到文件结尾<br>
            myFile.writeBytes(s+"\n");  //写入数据<br>
            myFile.close();<br>
        }<br>
        catch(IOException e){}<br>
    }<br>
}<br>
程序运行后在目录中建立一个 ep10_12.log 的文件，每次运行时输入的内容都会在该文件内容的结尾处添加。<br>
</div>

http://www.weixueyuan.net/view/6048.html
<h1>Java中文件的压缩处理</h1>
<div id="art-body">Java.util.zip 包中提供了可对文件的压缩和解压缩进行处理的类，它们继承自字节流类OutputSteam 和 InputStream。<span style="color:#b22222;">其中 GZIPOutputStream 和 ZipOutputStream 可分别把数据压缩成 GZIP 和 Zip 格式，GZIPInpputStream 和 ZipInputStream 又可将压缩的数据进行还原。</span><br>
<br>
<strong>将文件写入压缩文件的一般步骤如下：</strong>
<ol>
<li>
生成和所要生成的压缩文件相关联的压缩类对象。</li>
<li>
压缩文件通常不只包含一个文件，将每个要加入的文件称为一个压缩入口，使用ZipEntry(String FileName)生成压缩入口对象。</li>
<li>
使用 putNextEntry(ZipEntry entry)将压缩入口加入压缩文件。</li>
<li>
将文件内容写入此压缩文件。</li>
<li>
使用 closeEntry()结束目前的压缩入口，继续下一个压缩入口。</li>
</ol>
<br>
<strong>将文件从压缩文件中读出的一般步骤如下：</strong>
<ol>
<li>
生成和所要读入的压缩文件相关联的压缩类对象。</li>
<li>
利用 getNextEntry()得到下一个压缩入口。</li>
</ol>
<br>
【例 10-13】输入若干文件名，将所有文件压缩为“ep10_13.zip”，再从压缩文件中解压并显示。<br>
//********** ep10_13.java **********<br>
import java.io.*;<br>
import java.util.*;<br>
import java.util.zip.*;<br>
class ep10_13{<br>
    public static void main(String args[]) throws IOException{<br>
        FileOutputStream a=new FileOutputStream("ep10_13.zip");<br>
        //处理压缩文件<br>
        ZipOutputStream out=new ZipOutputStream(new BufferedOutputStream(a));<br>
        for(int i=0;i&lt;args.length;i++){  //对命令行输入的每个文件进行处理<br>
            System.out.println("Writing file"+args[i]);<br>
            BufferedInputStream in=new BufferedInputStream(new FileInputStream(args[i]));<br>
            out.putNextEntry(new ZipEntry(args[i]));  //设置 ZipEntry 对象<br>
            int b;<br>
            while((b=in.read())!=-1)<br>
                out.write(b);  //从源文件读出，往压缩文件中写入<br>
            in.close();<br>
        }<br>
        out.close();<br>
        //解压缩文件并显示<br>
        System.out.println("Reading file");<br>
        FileInputStream d=new FileInputStream("ep10_13.zip");<br>
        ZipInputStream  inout=new  ZipInputStream(new BufferedInputStream(d));<br>
        ZipEntry z;<br>
<br>
        while((z=inout.getNextEntry())!=null){  //获得入口<br>
            System.out.println("Reading file"+z.getName());  //显示文件初始名<br>
            int x;<br>
            while((x=inout.read())!=-1)<br>
                System.out.write(x);<br>
            System.out.println();<br>
        }<br>
        inout.close();<br>
    }<br>
}<br>
例 10-13 运行后，在程序目录建立一个 ep10_13.zip 的压缩文件，使用解压缩软件（如 WinRAR等），可以将其打开。命令提示符下，程序运行结果如图 10-12 所示：
<div style="text-align: center; ">
<img alt="图 10-12  例 10_13 运行结果" src="http://www.weixueyuan.net/uploads/allimg/130223/8-130223010044D3.png" style="width: 346px; height: 231px; "><br>
图 10-12  例 10_13 运行结果</div>
</div>

http://www.weixueyuan.net/view/6049.html