
<h1>Java类的定义及其实例化</h1>
<div id="art-body">如果你不了解类和对象的概念，请猛击这里：<a href="/view/6311.html" target="_blank">Java类和对象的概念</a><br>
<br>
类必须先定义才能使用。类是创建对象的模板，创建对象也叫类的实例化。<br>
<br>
下面通过一个简单的例子来理解Java中类的定义：
<pre class="java">
public class Dog{
    String name;
    int age;
   
    void bark(){  // 汪汪叫
        System.out.println("汪汪，不要过来");
    }
 
    void hungry(){  // 饥饿
        System.out.println("主人，我饿了");
    }
}</pre>
对示例的说明：
<ul>
<li>
public 是类的修饰符，表明该类是公共类，可以被其他类访问。修饰符将在下节讲解。</li>
<li>
class 是定义类的关键字。</li>
<li>
Dog 是类名称。</li>
<li>
name、age 是类的成员变量，也叫属性；bark()、hungry() 是类中的函数，也叫方法。</li>
</ul>
<br>
一个类可以包含以下类型变量：
<ul>
<li>
局部变量：在方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li>
成员变量：成员变量是定义在类中、方法体之外的变量。这种变量在创建对象的时候实例化（分配内存）。成员变量可以被类中的方法和特定类的语句访问。</li>
<li>
类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。static 也是修饰符的一种，将在下节讲解。</li>
</ul>
<h2>
构造方法</h2>
在类实例化的过程中自动执行的方法叫做构造方法，它不需要你手动调用。构造方法可以在类实例化的过程中做一些初始化的工作。<br>
<br>
构造方法的名称必须与类的名称相同，并且没有返回值。<br>
<br>
每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认的构造方法。<br>
<br>
下面是一个构造方法示例：
<pre class="java">
public class Dog{
    String name;
    int age;
   
    // 构造方法，没有返回值
    Dog(String name1, int age1){
        name = name1;
        age = age1;
        System.out.println("感谢主人领养了我");
    }
   
    // 普通方法，必须有返回值
    void bark(){
        System.out.println("汪汪，不要过来");
    }
 
    void hungry(){
        System.out.println("主人，我饿了");
    }
   
    public static void main(String arg[]){
        // 创建对象时传递的参数要与构造方法参数列表对应
        Dog myDog = new Dog("花花", 3);
    }
}</pre>
运行结果：<br>
感谢主人领养了我<br>
<br>
说明：
<ul>
<li>
构造方法不能被显示调用。</li>
<li>
构造方法不能有返回值，因为没有变量来接收返回值。</li>
</ul>
<h2>
创建对象</h2>
对象是类的一个实例，创建对象的过程也叫类的实例化。对象是以类为模板来创建的。<br>
<br>
在Java中，使用new关键字来创建对象，一般有以下三个步骤：
<ul>
<li>
声明：声明一个对象，包括对象名称和对象类型。</li>
<li>
实例化：使用关键字new来创建一个对象。</li>
<li>
初始化：使用new创建对象时，会调用构造方法初始化对象。</li>
</ul>
<br>
例如：
<pre class="java">
Dog myDog;  // 声明一个对象
myDog = new Dog("花花", 3);  // 实例化</pre>
也可以在声明的同时进行初始化：
<pre class="java">
Dog myDog = new Dog("花花", 3);</pre>
<h2>
访问成员变量和方法</h2>
通过已创建的对象来访问成员变量和成员方法，例如：
<pre class="java">
// 实例化
Dog myDog = new Dog("花花", 3);
// 通过点号访问成员变量
myDog.name;
// 通过点号访问成员方法
myDog.bark();</pre>
<br>
下面的例子演示了如何访问成员变量和方法：
<pre class="java">
public class Dog{
    String name;
    int age;
   
    Dog(String name1, int age1){
        name = name1;
        age = age1;
        System.out.println("感谢主人领养了我");
    }
   
    void bark(){
        System.out.println("汪汪，不要过来");
    }
 
    void hungry(){
        System.out.println("主人，我饿了");
    }
   
    public static void main(String arg[]){
        Dog myDog = new Dog("花花", 3);
        // 访问成员变量
        String name = myDog.name;
        int age = myDog.age;
        System.out.println("我是一只小狗，我名字叫" + name + "，我" + age + "岁了");
        // 访问方法
        myDog.bark();
        myDog.hungry();
    }
}</pre>
运行结果：<br>
感谢主人领养了我<br>
我是一只小狗，我名字叫花花，我3岁了<br>
汪汪，不要过来<br>
主人，我饿了</div>

http://www.weixueyuan.net/view/5980.html
<h1>Java访问修饰符（访问控制符）</h1>
<div id="art-body">Java 通过修饰符来控制类、属性和方法的访问权限和其他功能，通常放在语句的最前端。例如：
<pre class="java">
public class className {
    // body of class
}
private boolean myFlag;
static final double weeks = 9.5;
protected static final int BOXWIDTH = 42;
public static void main(String[] arguments) {
    // body of method
}</pre>
<br>
Java 的修饰符很多，分为访问修饰符和非访问修饰符。本节仅介绍访问修饰符，非访问修饰符会在后续介绍。<br>
<br>
访问修饰符也叫访问控制符，是指能够控制类、成员变量、方法的使用权限的关键字。<br>
<br>
在面向对象编程中，访问控制符是一个很重要的概念，可以使用它来保护对类、变量、方法和构造方法的访问。<br>
<br>
Java支持四种不同的访问权限：<br>
<table>
<tbody>
<tr>
<th>
修饰符</th>
<th>
说明</th>
</tr>
<tr>
<td>
public</td>
<td>
共有的，对所有类可见。</td>
</tr>
<tr>
<td>
protected</td>
<td>
受保护的，对同一包内的类和所有子类可见。</td>
</tr>
<tr>
<td>
private</td>
<td>
私有的，在同一类内可见。</td>
</tr>
<tr>
<td>
默认的</td>
<td>
在同一包内可见。默认不使用任何修饰符。</td>
</tr>
</tbody>
</table>
<h2>
public：公有的</h2>
被声明为public的类、方法、构造方法和接口能够被任何其他类访问。<br>
<br>
如果几个相互访问的public类分布在不用的包中，则需要导入相应public类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。<br>
<br>
下面的方法使用了公有访问控制：
<pre class="java">
public static void main(String[] arguments) {
    // body of method
}</pre>
Java程序的main() 方法必须设置成公有的，否则，Java解释器将不能运行该类。<br>
<h2>
protected：受保护的</h2>
被声明为protected的变量、方法和构造方法能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。<br>
<br>
protected访问修饰符不能修饰类和接口，方法和成员变量能够声明为protected，但是接口的成员变量和成员方法不能声明为protected。<br>
<br>
子类能访问protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。<br>
<br>
下面的父类使用了protected访问修饰符，子类重载了父类的bark()方法。
<pre class="java">
public class Dog{
    protected void bark() {
        System.out.println("汪汪，不要过来");
    }
}

class Teddy extends Dog{  // 泰迪
    void bark() {
        System.out.println("汪汪，我好怕，不要跟着我");
    }
}</pre>
如果把bark()方法声明为private，那么除了Dog之外的类将不能访问该方法。如果把bark()声明为public，那么所有的类都能够访问该方法。如果我们只想让该方法对其所在类的子类可见，则将该方法声明为protected。 <br>
<h2>
<strong>private：私有的</strong></h2>
私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。<br>
<br>
声明为私有访问类型的变量只能通过类中公共的Getter/Setter方法被外部类访问。<br>
<br>
private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。<br>
<br>
下面的类使用了私有访问修饰符：
<pre class="java">
public class Dog{
    private String name;
    private int age;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}</pre>
例子中，Dog类中的name、age变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两对public方法，getName()/setName() 和 getAge()/setAge()，它们用来获取和设置私有变量的值。<br>
<br>
this 是Java中的一个关键字，本章会讲到，你可以点击 <a href="/view/5988.html" target="_blank">Java this关键字详解</a> 预览。<br>
<br>
在类中定义访问私有变量的方法，习惯上是这样命名的：在变量名称前面加“get”或“set”，并将变量的首字母大写。例如，获取私有变量 name 的方法为 getName()，设置 name 的方法为 setName()。这些方法经常使用，也有了特定的称呼，称为 Getter 和 Setter 方法。<br>
<h2>
默认的：不使用任何关键字</h2>
<p>
不使用任何修饰符声明的属性和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final，而接口里的方法默认情况下访问权限为public。<br>
<br>
如下例所示，类、变量和方法的定义没有使用任何修饰符：</p>
<pre class="java">
class Dog{
    String name;
    int age;
  
    void bark(){  // 汪汪叫
        System.out.println("汪汪，不要过来");
    }

    void hungry(){  // 饥饿
        System.out.println("主人，我饿了");
    }
}</pre>
<h2>
<strong>访问控制和继承</strong></h2>
<p>
请注意以下方法继承（不了解继承概念的读者可以跳过这里，或者点击 <a href="/java/rumen_5/" target="_blank">Java继承和多态</a> 预览）的规则：</p>
<ul>
<li>
<p>
父类中声明为public的方法在子类中也必须为public。</p>
</li>
<li>
<p>
父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。</p>
</li>
<li>
<p>
父类中默认修饰符声明的方法，能够在子类中声明为private。</p>
</li>
<li>
<p>
父类中声明为private的方法，不能够被继承。</p>
</li>
</ul>
<h2>
如何使用访问控制符</h2>
访问控制符可以让我们很方便的控制代码的权限：<br>
<ul>
<li>
当需要让自己编写的类被所有的其他类访问时，就可以将类的访问控制符声明为 public。</li>
<li>
当需要让自己的类只能被自己的包中的类访问时，就可以省略访问控制符。</li>
<li>
当需要控制一个类中的成员数据时，可以将这个类中的成员数据访问控制符设置为 public、protected，或者省略。</li>
</ul>
</div>

http://www.weixueyuan.net/view/5981.html
<h1>Java类的基本运行顺序</h1>
<div id="art-body">我们以下面的类来说明一个基本的 Java 类的运行顺序：
<pre class="java">
public class Demo{
    private String name;
    private int age;

    public Demo(){
        name = "微学苑";
        age = 3;
    }
    public static void main(String[] args){
        Demo obj = new Demo();
        System.out.println(obj.name + "的年龄是" + obj.age);
    }
}</pre>
基本运行顺序是：
<ol>
<li>
先运行到第 9 行，这是程序的入口。</li>
<li>
然后运行到第 10 行，这里要 new 一个Demo，就要调用 Demo 的构造方法。</li>
<li>
就运行到第 5 行，注意：可能很多人觉得接下来就应该运行第 6 行了，错！初始化一个类，必须先初始化它的属性。</li>
<li>
因此运行到第 2 行，然后是第 3 行。</li>
<li>
属性初始化完过后，才回到构造方法，执行里面的代码，也就是第 6 行、第 7 行。</li>
<li>
然后是第8行，表示 new 一个Demo实例完成。</li>
<li>
然后回到 main 方法中执行第 11 行。</li>
<li>
然后是第 12 行，main方法执行完毕。</li>
</ol>
<br>
作为程序员，应该清楚程序的基本运行过程，否则糊里糊涂的，不利于编写代码，也不利于技术上的发展。 <br>
</div>

http://www.weixueyuan.net/view/5984.html
<h1>Java变量的作用域</h1>
<div id="art-body">在Java中，变量的作用域分为四个级别：类级、对象实例级、方法级、块级。<br>
<br>
类级变量又称全局级变量或静态变量，需要使用static关键字修饰，你可以与 C/C++ 中的 static 变量对比学习。类级变量在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。<br>
<br>
对象实例级变量就是成员变量，实例化后才会分配内存空间，才能访问。<br>
<br>
方法级变量就是在方法内部定义的变量，就是局部变量。<br>
<br>
块级变量就是定义在一个块内部的变量，变量的生存周期就是这个块，出了这个块就消失了，比如 if、for 语句的块。块是指由大括号包围的代码，例如：
<pre class="java">
{
    int age = 3;
    String name = "www.weixueyuan.net";
    // 正确，在块内部可以访问 age 和 name 变量
    System.out.println( name + "已经" + age + "岁了");
}
// 错误，在块外部无法访问 age 和 name 变量
System.out.println( name + "已经" + age + "岁了");</pre>
<br>
说明：
<ul>
<li>
方法内部除了能访问方法级的变量，还可以访问类级和实例级的变量。</li>
<li>
块内部能够访问类级、实例级变量，如果块被包含在方法内部，它还可以访问方法级的变量。</li>
<li>
方法级和块级的变量必须被显示地初始化，否则不能访问。</li>
</ul>
<br>
演示代码：
<pre class="java">
public class Demo{
    public static String name = "微学苑";  // 类级变量
    public int i; // 对象实例级变量

    // 属性块，在类初始化属性时候运行
    {
        int j = 2;// 块级变量
    }

    public void test1() {
        int j = 3;  // 方法级变量
        if(j == 3) {
            int k = 5;  // 块级变量
        }
        // 这里不能访问块级变量，块级变量只能在块内部访问
        System.out.println("name=" + name + ", i=" + i + ", j=" + j);
    }

    public static void main(String[] args) {
        // 不创建对象，直接通过类名访问类级变量
        System.out.println(Demo.name);
       
        // 创建对象并访问它的方法
        Demo t = new Demo();
        t.test1();
    }
}</pre>
运行结果：<br>
微学苑<br>
name=微学苑, i=0, j=3</div>

http://www.weixueyuan.net/view/5986.html
<h1>Java this关键字详解</h1>
<div id="art-body">this 关键字用来表示当前对象本身，或当前类的一个实例，通过 this 可以调用本对象的所有方法和属性。例如：
<pre class="java">
public class Demo{
    public int x = 10;
    public int y = 15;

    public void sum(){
        // 通过 this 点取成员变量
        int z = this.x + this.y;
        System.out.println("x + y = " + z);
    }
  
    public static void main(String[] args) {
        Demo obj = new Demo();
        obj.sum();
    }
}</pre>
运行结果：<br>
x + y = 25<br>
<br>
上面的程序中，obj 是 Demo 类的一个实例，this 与 obj 等价，执行 int z = this.x + this.y;，就相当于执行 int z = obj.x + obj.y;。<br>
<br>
注意：this 只有在类实例化后才有意义。
<h2>
使用this区分同名变量</h2>
成员变量与方法内部的变量重名时，希望在方法内部调用成员变量，怎么办呢？这时候只能使用this，例如：<br>
<pre class="java">
public class Demo{
    public String name;
    public int age;
  
    public Demo(String name, int age){
        this.name = name;
        this.age = age;
    }
  
    public void say(){
        System.out.println("网站的名字是" + name + "，已经成立了" + age + "年");
    }
  
    public static void main(String[] args) {
        Demo obj = new Demo("微学苑", 3);
        obj.say();
    }
}</pre>
运行结果：<br>
网站的名字是微学苑，已经成立了3年<br>
<br>
形参的作用域是整个方法体，是局部变量。在Demo()中，形参和成员变量重名，如果不使用this，访问到的就是局部变量name和age，而不是成员变量。在 say() 中，我们没有使用 this，因为成员变量的作用域是整个实例，当然也可以加上 this：
<pre class="java">
public void say(){
    System.out.println("网站的名字是" + this.name + "，已经成立了" + this.age + "年");
} </pre>
Java 默认将所有成员变量和成员方法与 this 关联在一起，因此使用 this 在某些情况下是多余的。
<h2>
作为方法名来初始化对象</h2>
也就是相当于调用本类的其它构造方法，它必须作为构造方法的第一句。示例如下：
<pre class="java">
public class Demo{
    public String name;
    public int age;
   
    public Demo(){
        this("微学苑", 3);
    }
  
    public Demo(String name, int age){
        this.name = name;
        this.age = age;
    }
  
    public void say(){
        System.out.println("网站的名字是" + name + "，已经成立了" + age + "年");
    }
  
    public static void main(String[] args) {
        Demo obj = new Demo();
        obj.say();
    }
}</pre>
运行结果：<br>
网站的名字是微学苑，已经成立了3年<br>
<br>
值得注意的是：
<ul>
<li>
在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。</li>
<li>
不能在构造方法以外的任何方法内调用构造方法。</li>
<li>
在一个构造方法内只能调用一个构造方法。</li>
</ul>
<br>
上述代码涉及到方法重载，即Java允许出现多个同名方法，只要参数不同就可以。后续章节会讲解。
<h2>
作为参数传递</h2>
需要在某些完全分离的类中调用一个方法，并将当前对象的一个引用作为参数传递时。例如：
<pre class="java">
public class Demo{
    public static void main(String[] args){
        B b = new B(new A());
    }
}

class A{
    public A(){
        new B(this).print();  // 匿名对象
    }
    public void print(){
        System.out.println("Hello from A!");
    }
}

class B{
    A a;
    public B(A a){
        this.a = a;
    }
    public void print() {
        a.print();
        System.out.println("Hello from B!");
    }
}</pre>
运行结果：<br>
Hello from A!<br>
Hello from B!<br>
<br>
匿名对象就是没有名字的对象。如果对象只使用一次，就可以作为匿名对象，代码中 new B(this).print(); 等价于 ( new B(this) ).print();，先通过 new B(this) 创建一个没有名字的对象，再调用它的方法。</div>

http://www.weixueyuan.net/view/5988.html
<h1>Java方法重载</h1>
<div id="art-body">在Java中，同一个类中的多个方法可以有相同的名字，只要它们的参数列表不同就可以，这被称为<span style="color:#b22222;">方法重载(method overloading)</span>。<br>
<br>
参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。<br>
<br>
重载是面向对象的一个基本特性。<br>
<br>
下面看一个详细的实例。
<pre class="java">
public class Demo{
    // 一个普通的方法，不带参数
    void test(){
        System.out.println("No parameters");
    }
    // 重载上面的方法，并且带了一个整型参数
    void test(int a){
        System.out.println("a: " + a);
    }
    // 重载上面的方法，并且带了两个参数
    void test(int a,int b){
        System.out.println("a and b: " + a + " " + b);
    }
    // 重载上面的方法，并且带了一个双精度参数
    double test(double a){
        System.out.println("double a: " + a);
        return a*a;
    }
   
    public static void main(String args[]){
        Demo obj= new Demo();
        obj.test();
        obj.test(2);
        obj.test(2,3);
        obj.test(2.0);
    }
}</pre>
运行结果：<br>
No parameters<br>
a: 2<br>
a and b: 2 3<br>
double a: 2.0<br>
<br>
通过上面的实例，读者可以看出，重载就是在一个类中，有相同的函数名称，但形参不同的函数。重载的结果，可以让一个程序段尽量减少代码和方法的种类。<br>
<br>
<strong>说明：</strong>
<ul>
<li>
参数列表不同包括：个数不同、类型不同和顺序不同。</li>
<li>
仅仅参数变量名称不同是不可以的。</li>
<li>
跟成员方法一样，构造方法也可以重载。</li>
<li>
声明为final的方法不能被重载。</li>
<li>
声明为static的方法不能被重载，但是能够被再次声明。</li>
</ul>
<br>
<strong>方法的重载的规则：</strong>
<ul>
<li>
方法名称必须相同。</li>
<li>
参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）。</li>
<li>
方法的返回类型可以相同也可以不相同。</li>
<li>
仅仅返回类型不同不足以成为方法的重载。</li>
</ul>
<br>
<strong>方法重载的实现：</strong><br>
方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错，这叫做<span style="color:#b22222;">重载分辨</span>。<br>
</div>

http://www.weixueyuan.net/view/5989.html
<h1>Java包装类、拆箱和装箱详解</h1>
<div id="art-body">虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。<br>
<br>
这种借助于非面向对象技术的做法有时也会带来不便，比如引用类型数据均继承了 Object 类的特性，要转换为 String 类型（经常有这种需要）时只要简单调用 Object 类中定义的toString()即可，而基本数据类型转换为 String 类型则要麻烦得多。为解决此类问题 ，Java为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes)，也有教材称为外覆类或数据类型类。<br>
<br>
<table>
<caption>
基本数据类型及对应的包装类</caption>
<tbody>
<tr>
<th>
基本数据类型</th>
<th>
对应的包装类</th>
</tr>
<tr>
<td>
byte</td>
<td>
Byte</td>
</tr>
<tr>
<td>
short</td>
<td>
Short</td>
</tr>
<tr>
<td>
int</td>
<td>
Integer</td>
</tr>
<tr>
<td>
long</td>
<td>
Long</td>
</tr>
<tr>
<td>
char</td>
<td>
Character</td>
</tr>
<tr>
<td>
float</td>
<td>
Float</td>
</tr>
<tr>
<td>
double</td>
<td>
Double</td>
</tr>
<tr>
<td>
boolean</td>
<td>
Boolean</td>
</tr>
</tbody>
</table>
<br>
每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。<br>
<br>
基本类型和对应的包装类可以相互装换：
<ul>
<li>
由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象；</li>
<li>
包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int。</li>
</ul>
<h2>
包装类的应用</h2>
八个包装类的使用比较相似，下面是常见的应用场景。
<h4>
1) 实现 int 和 Integer 的相互转换</h4>
可以通过 Integer 类的构造方法将 int 装箱，通过 Integer 类的 intValue 方法将 Integer 拆箱。例如：
<pre class="java">
public class Demo {
    public static void main(String[] args) {
        int m = 500;
        Integer obj = new Integer(m);  // 手动装箱
        int n = obj.intValue();  // 手动拆箱
        System.out.println("n = " + n);
       
        Integer obj1 = new Integer(500);
        System.out.println("obj 等价于 obj1？" + obj.equals(obj1));
    }
}</pre>
运行结果：<br>
n = 500<br>
obj 等价于 obj1？true
<h4>
2) 将字符串转换为整数</h4>
Integer 类有一个静态的 paseInt() 方法，可以将字符串转换为整数，语法为：
<pre class="java">
parseInt(String s, int radix);</pre>
s 为要转换的字符串，radix 为进制，可选，默认为十进制。<br>
<br>
下面的代码将会告诉你什么样的字符串可以转换为整数：
<pre class="java">
public class Demo {
    public static void main(String[] args) {
        String str[] = {"123", "123abc", "abc123", "abcxyz"};
       
        for(String str1 : str){
            try{
                int m = Integer.parseInt(str1, 10);
                System.out.println(str1 + " 可以转换为整数 " + m);
            }catch(Exception e){
                System.out.println(str1 + " 无法转换为整数");
            }
        }
    }
}</pre>
运行结果：<br>
123 可以转换为整数 123<br>
123abc 无法转换为整数<br>
abc123 无法转换为整数<br>
abcxyz 无法转换为整数
<h4>
3) 将整数转换为字符串</h4>
Integer 类有一个静态的 toString() 方法，可以将整数转换为字符串。例如：
<pre class="java">
public class Demo {
    public static void main(String[] args) {
        int m = 500;
        String s = Integer.toString(m);
        System.out.println("s = " + s);
    }
}</pre>
运行结果：<br>
s = 500
<h2>
自动拆箱和装箱</h2>
上面的例子都需要手动实例化一个包装类，称为手动拆箱装箱。Java 1.5(5.0) 之前必须手动拆箱装箱。<br>
<br>
Java 1.5 之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。例如：
<pre class="java">
public class Demo {
    public static void main(String[] args) {
        int m = 500;
        Integer obj = m;  // 自动装箱
        int n = obj;  // 自动拆箱
        System.out.println("n = " + n);
      
        Integer obj1 = 500;
        System.out.println("obj 等价于 obj1？" + obj.equals(obj1));
    }
}</pre>
运行结果：<br>
n = 500<br>
obj 等价于 obj1？true<br>
<br>
自动拆箱装箱是常用的一个功能，读者需要重点掌握。</div>

http://www.weixueyuan.net/view/5990.html
<h1>再谈Java包</h1>
<div id="art-body">在Java中，为了组织代码的方便，可以将功能相似的类放到一个文件夹内，这个文件夹，就叫做包。<br>
<br>
包不但可以包含类，还可以包含接口和其他的包。<br>
<br>
目录以"\"来表示层级关系，例如 E:\Java\workspace\Demo\bin\p1\p2\Test.java。<br>
<br>
包以"."来表示层级关系，例如 p1.p2.Test 表示的目录为 \p1\p2\Test.class。
<h2>
如何实现包</h2>
通过 package 关键字可以声明一个包，例如：<br>
    package p1.p2;<br>
必须将 package 语句放在所有语句的前面，例如：
<pre class="java">
package p1.p2;
public class Test {
    public Test(){
        System.out.println("我是Test类的构造方法");
    }
}</pre>
表明 Test 类位于 p1.p2 包中。
<h2>
包的调用</h2>
在Java中，调用其他包中的类共有两种方式。<br>
<h4>
1) 在每个类名前面加上完整的包名</h4>
程序举例：
<pre class="java">
public class Demo {
    public static void main(String[] args) {
        java.util.Date today=new java.util.Date();
        System.out.println(today);
    }
}</pre>
运行结果：<br>
Wed Dec 03 11:20:13 CST 2014
<h4>
2) 通过 import 语句引入包中的类</h4>
程序举例：
<pre class="java">
import java.util.Date;
// 也可以引入 java.util 包中的所有类
// import java.util.*;

public class Demo {
    public static void main(String[] args) {
        Date today=new Date();
        System.out.println(today);
    }
}</pre>
运行结果与上面相同。<br>
<br>
实际编程中，没有必要把要引入的类写的那么详细，可以直接引入特定包中所有的类，例如 import java.util.*;。
<h2>
类的路径</h2>
Java 在导入类时，必须要知道类的绝对路径。<br>
<br>
首先在 E:\Java\workspace\Demo\src\p0\ 目录（E:\Java\workspace\Demo\src\ 是项目源文件的根目录）下创建 Demo.java，输入如下代码：
<pre class="java">
package p0;
import p1.p2.Test;

public class Demo{
    public static void main(String[] args){
        Test obj = new Test();
    }
}</pre>
<br>
再在 E:\Java\workspace\Demo\src\p1\p2 目录下创建 Test.java，输入如下代码：
<pre class="java">
package p1.p2;

public class Test {
    public Test(){
        System.out.println("我是Test类的构造方法");
    }
}</pre>
<br>
假设我们将 classpath 环境变量设置为 .;D:\Program Files\jdk1.7.0_71\lib，源文件 Demo.java 开头有 import p1.p2.Test; 语句，那么编译器会先检查 E:\Java\workspace\Demo\src\p0\p1\p2\ 目录下是否存在 Test.java 或 Test.class 文件，如果不存在，会继续检索 D:\Program Files\jdk1.7.0_71\lib\p1\p2\ 目录，两个目录下都不存在就会报错。显然，Test.java 位于 E:\Java\workspace\Demo\src\p1\p2\ 目录，编译器找不到，会报错，怎么办呢？<br>
<br>
可以通过 javac 命令的 classpath 选项来指定类路径。<br>
<br>
打开CMD，进入 Demo.java 文件所在目录，执行 javac 命令，并将 classpath 设置为 E:\Java\workspace\Demo\src，如下图所示：<br>
<img alt="" src="http://www.weixueyuan.net/uploads/allimg/141203/1-141203102603222.png" style="width: 606px; height: 150px;"><br>
<br>
运行Java程序时，也需要知道类的绝对路径，除了 classpath 环境变量指定的路径，也可以通过 java 命令的 classpath 选项来增加路径，如下图所示：<br>
<img alt="" src="http://www.weixueyuan.net/uploads/allimg/141203/1-141203103J1410.png" style="width: 556px; height: 144px;"><br>
<br>
注意 java 命令与 javac 命令的区别，执行 javac 命令需要进入当前目录，而执行 java 命令需要进入当前目录的上级目录，并且类名前面要带上包名。<br>
<br>
可以这样来理解，javac是一个平台命令，它对具体的平台文件进行操作，要指明被编译的文件路径。而java是一个虚拟机命令，它对类操作，即对类的描述要用点分的描述形式，并且不能加扩展名，还要注意类名的大小写。<br>
<br>
这些命令比较繁杂，实际开发都需要借助 Eclipse，在Eclipse下管理包、编译运行程序都非常方便。Eclipse 实际上也是执行这些命令。
<h2>
包的访问权限</h2>
被声明为 public 的类、方法或成员变量，可以被任何包下的任何类使用，而声明为 private 的类、方法或成员变量，只能被本类使用。<br>
<br>
没有任何修饰符的类、方法和成员变量，只能被本包中的所有类访问，在包以外任何类都无法访问它。<br>
</div>

http://www.weixueyuan.net/view/6319.html
<h1>Java源文件的声明规则</h1>
<div id="art-body">当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则：
<ul>
<li>
一个源文件中只能有一个public类。</li>
<li>
一个源文件可以有多个非public类。</li>
<li>
源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</li>
<li>
如果一个类定义在某个包中，那么package语句应该在源文件的首行。</li>
<li>
如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</li>
<li>
import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
<li>
类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在后续章节介绍。</li>
<li>
除了上面提到的几种类型，Java还有一些特殊的类，如内部类、匿名类。 </li>
</ul>
<h2>
一个简单的例子</h2>
在该例子中，我们创建两个类 Employee 和 EmployeeTest，分别放在包 p1 和 p2 中。<br>
<br>
Employee类有四个成员变量，分别是 name、age、designation和salary。该类显式声明了一个构造方法，该方法只有一个参数。<br>
<br>
在Eclipse中，创建一个包，命名为 p1，在该包中创建一个类，命名为 Employee，将下面的代码复制到源文件中：
<pre class="java">
package p1;

public class Employee{
    String name;
    int age;
    String designation;
    double salary;
    // Employee 类的构造方法
    public Employee(String name){
        this.name = name;
    }
    // 设置age的值
    public void empAge(int empAge){
        age =  empAge;
    }
    // 设置designation的值
    public void empDesignation(String empDesig){
        designation = empDesig;
    }
    // 设置salary的值
    public void empSalary(double empSalary){
        salary = empSalary;
    }
    // 输出信息
    public void printEmployee(){
        System.out.println("Name:"+ name );
        System.out.println("Age:" + age );
        System.out.println("Designation:" + designation );
        System.out.println("Salary:" + salary);
    }
}</pre>
<br>
程序都是从main方法开始执行。为了能运行这个程序，必须包含main方法并且创建一个对象。<br>
<br>
下面给出EmployeeTest类，该类创建两个Employee对象，并调用方法设置变量的值。<br>
<br>
在Eclipse中再创建一个包，命名为 p2，在该包中创建一个类，命名为 EmployeeTest，将下面的代码复制到源文件中：
<pre class="java">
package p2;
import p1.*;

public class EmployeeTest{
    public static void main(String args[]){
        // 创建两个对象
        Employee empOne = new Employee("James Smith");
        Employee empTwo = new Employee("Mary Anne");

        // 调用这两个对象的成员方法
        empOne.empAge(26);
        empOne.empDesignation("Senior Software Engineer");
        empOne.empSalary(1000);
        empOne.printEmployee();

        empTwo.empAge(21);
        empTwo.empDesignation("Software Engineer");
        empTwo.empSalary(500);
        empTwo.printEmployee();
    }
}</pre>
编译并运行 EmployeeTest 类，可以看到如下的输出结果：<br>
Name:James Smith<br>
Age:26<br>
Designation:Senior Software Engineer<br>
Salary:1000.0<br>
Name:Mary Anne<br>
Age:21<br>
Designation:Software Engineer<br>
Salary:500.0<br>
</div>

http://www.weixueyuan.net/view/6320.html