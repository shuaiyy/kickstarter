
<h1>Java内部类及其实例化</h1>
<div id="art-body">在 Java 中，允许在一个类（或方法、语句块）的内部定义另一个类，称为<span style="color:#b22222;">内部类(Inner Class)</span>，有时也称为嵌套类<span style="color:#b22222;">(Nested Class)</span>。<br>
<br>
内部类和外层封装它的类之间存在逻辑上的所属关系，一般只用在定义它的类或语句块之内，实现一些没有通用意义的功能逻辑，在外部引用它时必须给出完整的名称。<br>
<br>
使用内部类的主要原因有：
<ul>
<li>
内部类可以访问外部类中的数据，包括私有的数据。</li>
<li>
内部类可以对同一个包中的其他类隐藏起来。</li>
<li>
当想要定义一个回调函数且不想编写大量代码时，使用<span style="color:#b22222;">匿名(anonymous)内部类</span>比较便捷。</li>
<li>
减少类的命名冲突。</li>
</ul>
<br>
请看下面的例子：
<pre class="java">
public class Outer {
    private int size;
    public class Inner {
        private int counter = 10;
        public void doStuff() {
            size++;
        }
    }
    public static void main(String args[]) {
        Outer outer = new Outer();
        Inner inner = outer.new Inner();
        inner.doStuff();
        System.out.println(outer.size);
        System.out.println(inner.counter);
        // 编译错误，外部类不能访问内部类的变量
        System.out.println(counter);
    }
}</pre>
这段代码定义了一个外部类 Outer，它包含了一个内部类 Inner。将错误语句注释掉，编译，会生成两个 .class 文件：Outer.class 和 Outer$Inner.class。也就是说，内部类会被编译成独立的字节码文件。<br>
<br>
内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用 $ 符号分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。<br>
<br>
<span style="color:#b22222;">注意：必须先有外部类的对象才能生成内部类的对象，因为内部类需要访问外部类中的成员变量，成员变量必须实例化才有意义。</span><br>
<br>
内部类是 Java 1.1 的新增特性，有些程序员认为这是一个值得称赞的进步，但是内部类的语法很复杂，严重破坏了良好的代码结构， 违背了Java要比C++更加简单的设计理念。<br>
<br>
内部类看似增加了—些优美有趣，实属没必要的特性，这是不是也让Java开始走上了许多语言饱受折磨的毁灭性道路呢？本教程并不打算就这个问题给予一个肯定的答案。<br>
</div>

http://www.weixueyuan.net/view/6006.html
<h1>Java静态内部类、匿名内部类、成员式内部类和局部内部类</h1>
<div id="art-body">内部类可以是静态(static)的，可以使用 public、protected 和 private 访问控制符，而外部类只能使用 public，或者默认。<br>
<h2>
成员式内部类</h2>
在外部类内部直接定义（不在方法内部或代码块内部）的类就是成员式内部类，它可以直接使用外部类的所有变量和方法，即使是 private 的。外部类要想访问内部类的成员变量和方法，则需要通过内部类的对象来获取。<br>
<br>
请看下面的代码：
<pre class="java">
public class Outer{
    private int size;
    public class Inner {
        public void dostuff() {
            size++;
        }
    }
    public void testTheInner() {
        Inner in = new Inner();
        in.dostuff();
    }
}</pre>
成员式内部类如同外部类的一个普通成员。<br>
<br>
成员式内部类可以使用各种修饰符，包括 public、protected、private、static、final 和 abstract，也可以不写。<br>
<br>
若有 static 修饰符，就为类级，否则为对象级。类级可以通过外部类直接访问，对象级需要先生成外部的对象后才能访问。<br>
<br>
非静态内部类中不能声明任何 static 成员。<br>
<br>
内部类可以相互调用，例如：
<pre class="java">
class A {
    // B、C 间可以互相调用
    class B {}
    class C {}
}</pre>
<h4>
成员式内部类的访问</h4>
内部类的对象以成员变量的方式记录其所依赖的外层类对象的引用，因而可以找到该外层类对象并访问其成员。该成员变量是系统自动为非 static 的内部类添加的，名称约定为“outClassName.this”。<br>
<br>
1) 使用内部类中定义的非静态变量和方法时，要先创建外部类的对象，再由“outObjectName.new”操作符创建内部类的对象，再调用内部类的方法，如下所示：
<pre class="java">
public class Demo{
    public static void main(String[] args) {
        Outer outer = new Outer();
        Outer.Inner inner = outer.new Inner();
        inner.dostuff();
    }
}
class Outer{
    private int size;
    class Inner{
        public void dostuff() {
            size++;
        }
    }
}</pre>
<br>
2) static 内部类相当于其外部类的 static 成员，它的对象与外部类对象间不存在依赖关系，因此可直接创建。示例如下：
<pre class="java">
public class Demo{
    public static void main(String[] args) {
        Outer.Inner inner = new Outer.Inner();
        inner.dostuff();
    }
}

class Outer{
    private static int size;
    static class Inner {
        public void dostuff() {
            size++;
            System.out.println("size=" + size);
        }
    }
}</pre>
运行结果：<br>
size=1<br>
<br>
3) 由于内部类可以直接访问其外部类的成分，因此当内部类与其外部类中存在同名属性或方法时，也将导致命名冲突。所以在多层调用时要指明，如下所示：
<pre class="java">
public class Outer{
    private int size;
    public class Inner{
        private int size;
        public void dostuff(int size){
            size++;  // 局部变量 size;
            this.size;  // 内部类的 size
            Outer.this.size++;  // 外部类的 size
        }
    }
}</pre>
<h2>
局部内部类</h2>
局部内部类(Local class)是定义在代码块中的类。它们只在定义它们的代码块中是可见的。<br>
<br>
局部类有几个重要特性：
<ol>
<li>
仅在定义了它们的代码块中是可见的；</li>
<li>
可以使用定义它们的代码块中的任何局部 final 变量；</li>
<li>
局部类不可以是 static 的，里边也不能定义 static 成员；</li>
<li>
局部类不可以用 public、private、protected 修饰，只能使用缺省的；</li>
<li>
局部类可以是 abstract 的。</li>
</ol>
<br>
请看下面的代码：
<pre class="java">
public class Outer {
    public static final int TOTAL_NUMBER = 5;
    public int id = 123;
    public void func() {
        final int age = 15;
        String str = "http://www.weixueyuan.net";
        class Inner {
            public void innerTest() {
                System.out.println(TOTAL_NUMBER);
                System.out.println(id);
                // System.out.println(str);不合法，只能访问本地方法的final变量
                System.out.println(age);
            }
        }
        new Inner().innerTest();
    }
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.func();
    }
}</pre>
运行结果：<br>
5<br>
123<br>
15<br>
<h2>
匿名内部类</h2>
匿名内部类是局部内部类的一种特殊形式，也就是没有变量名指向这个类的实例，而且具体的类实现会写在这个内部类里面。<br>
<br>
注意：匿名类必须继承一个父类或实现一个接口。<br>
<br>
不使用匿名内部类来实现抽象方法：
<pre class="java">
abstract class Person {
    public abstract void eat();
}

class Child extends Person {
    public void eat() {
        System.out.println("eat something");
    }
}

public class Demo {
    public static void main(String[] args) {
        Person p = new Child();
        p.eat();
    }
}</pre>
运行结果：<br>
eat something<br>
<br>
可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用。但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？<br>
<br>
这个时候就引入了匿名内部类。使用匿名内部类实现：
<pre class="java">
abstract class Person {
    public abstract void eat();
}

public class Demo {
    public static void main(String[] args){
       
        // 继承 Person 类
        new Person() {
            public void eat() {
                System.out.println("eat something");
            }
        }.eat();
    }
}</pre>
可以看到，匿名类继承了 Person 类并在大括号中实现了抽象类的方法。<br>
<br>
内部类的语法比较复杂，实际开发中也较少用到，本教程不打算进行深入讲解，各位读者也不应该将内部类作为学习Java的重点。</div>

http://www.weixueyuan.net/view/6007.html
<h1>Java抽象类的概念和使用</h1>
<div id="art-body">在自上而下的继承层次结构中，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，它只包含一些最基本的成员，人们只将它作为派生其他类的基类，而不会用来创建对象。甚至，你可以只给出方法的定义而不实现，由子类根据具体需求来具体实现。<br>
<br>
这种只给出方法定义而不具体实现的方法被称为<span style="color:#b22222;">抽象方法</span>，抽象方法是没有方法体的，在代码的表达上就是没有“{}”。包含一个或多个抽象方法的类也必须被声明为<span style="color:#b22222;">抽象类</span>。<br>
<br>
使用 abstract 修饰符来表示抽象方法和抽象类。<br>
<br>
抽象类除了包含抽象方法外，还可以包含具体的变量和具体的方法。类即使不包含抽象方法，也可以被声明为抽象类，防止被实例化。<br>
<br>
抽象类不能被实例化，抽象方法必须在子类中被实现。请看下面的代码：
<pre class="java">
import static java.lang.System.*;

public final class Demo{
    public static void main(String[] args) {
        Teacher t = new Teacher();
        t.setName("王明");
        t.work();
       
        Driver d = new Driver();
        d.setName("小陈");
        d.work();
    }
}

// 定义一个抽象类
abstract class People{
    private String name;  // 实例变量
   
    // 共有的 setter 和 getter 方法
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return this.name;
    }
   
    // 抽象方法
    public abstract void work();
}

class Teacher extends People{
    // 必须实现该方法
    public void work(){
        out.println("我的名字叫" + this.getName() + "，我正在讲课，请大家不要东张西望...");
    }
}

class Driver extends People{
    // 必须实现该方法
    public void work(){
        out.println("我的名字叫" + this.getName() + "，我正在开车，不能接听电话...");
    }
}</pre>
运行结果：<br>
我的名字叫王明，我正在讲课，请大家不要东张西望...<br>
我的名字叫小陈，我正在开车，不能接听电话...<br>
<br>
关于抽象类的几点说明：
<ul>
<li>
抽象类不能直接使用，必须用子类去实现抽象类，然后使用其子类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例，也就是可以使用抽象类来充当形参，实际实现类作为实参，也就是多态的应用。</li>
<li>
不能有抽象构造方法或抽象静态方法。 </li>
</ul>
<br>
<br>
在下列情况下，一个类将成为抽象类：
<ol>
<li>
当一个类的一个或多个方法是抽象方法时；</li>
<li>
当类是一个抽象类的子类，并且不能为任何抽象方法提供任何实现细节或方法主体时；</li>
<li>
当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法主体时；注意：
<ul>
<li>
这里说的是这些情况下一个类将成为抽象类，没有说抽象类一定会有这些情况。</li>
<li>
一个典型的错误：抽象类一定包含抽象方法。 但是反过来说“包含抽象方法的类一定是抽象类”就是正确的。</li>
<li>
事实上，抽象类可以是一个完全正常实现的类</li>
</ul>
</li>
</ol>
</div>

http://www.weixueyuan.net/view/6008.html
<h1>Java接口(interface)的概念及使用</h1>
<div id="art-body">在抽象类中，可以包含一个或多个抽象方法；但在接口(interface)中，所有的方法必须都是抽象的，不能有方法体，它比抽象类更加“抽象”。<br>
<br>
接口使用 interface 关键字来声明，可以看做是一种特殊的抽象类，可以指定一个类必须做什么，而不是规定它如何去做。<br>
<br>
现实中也有很多接口的实例，比如说串口电脑硬盘，Serial ATA委员会指定了Serial ATA 2.0规范，这种规范就是接口。Serial ATA委员会不负责生产硬盘，只是指定通用的规范。<br>
<br>
希捷、日立、三星等生产厂家会按照规范生产符合接口的硬盘，这些硬盘就可以实现通用化，如果正在用一块160G日立的串口硬盘，现在要升级了，可以购买一块320G的希捷串口硬盘，安装上去就可以继续使用了。<br>
<br>
下面的代码可以模拟Serial ATA委员会定义以下串口硬盘接口：
<pre class="java">
//串行硬盘接口
public interface SataHdd{
    //连接线的数量
    public static final int CONNECT_LINE=4;
    //写数据
    public void writeData(String data);
    //读数据
    public String readData();
}</pre>
<span style="color:#b22222;">注意：接口中声明的成员变量默认都是 public static final 的，必须显示的初始化。因而在常量声明时可以省略这些修饰符。</span><br>
<br>
接口是若干常量和抽象方法的集合，目前看来和抽象类差不多。确实如此，接口本就是从抽象类中演化而来的，因而除特别规定，接口享有和类同样的“待遇”。比如，源程序中可以定义多个类或接口，但最多只能有一个public 的类或接口，如果有则源文件必须取和public的类和接口相同的名字。和类的继承格式一样，接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法等。<br>
<br>
但接口有其自身的一些特性，归纳如下。<br>
<br>
1) 接口中只能定义抽象方法，这些方法默认为 public abstract 的，因而在声明方法时可以省略这些修饰符。试图在接口中定义实例变量、非抽象的实例方法及静态方法，都是非法的。例如：
<pre class="java">
public interface SataHdd{
    //连接线的数量
    public int connectLine; //编译出错，connectLine被看做静态常量，必须显式初始化
    //写数据
    protected void writeData(String data); //编译出错，必须是public类型
    //读数据
    public static String readData(){ //编译出错，接口中不能包含静态方法
        return "数据"; //编译出错，接口中只能包含抽象方法，
    }
}</pre>
<br>
3) 接口中没有构造方法，不能被实例化。<br>
<br>
4) 一个接口不实现另一个接口，但可以继承多个其他接口。接口的多继承特点弥补了类的单继承。例如：
<pre class="java">
//串行硬盘接口
public interface SataHdd extends A,B{
    // 连接线的数量
    public static final int CONNECT_LINE = 4;
    // 写数据
    public void writeData(String data);
    // 读数据
    public String readData();
}
interface A{
    public void a();
}
interface B{
    public void b();
}</pre>
<h2>
为什么使用接口</h2>
大型项目开发中，可能需要从继承链的中间插入一个类，让它的子类具备某些功能而不影响它们的父类。例如 A -&gt; B -&gt; C -&gt; D -&gt; E，A 是祖先类，如果需要为C、D、E类添加某些通用的功能，最简单的方法是让C类再继承另外一个类。但是问题来了，Java 是一种单继承的语言，不能再让C继承另外一个父类了，只到移动到继承链的最顶端，让A再继承一个父类。这样一来，对C、D、E类的修改，影响到了整个继承链，不具备可插入性的设计。<br>
<br>
接口是可插入性的保证。在一个继承链中的任何一个类都可以实现一个接口，这个接口会影响到此类的所有子类，但不会影响到此类的任何父类。此类将不得不实现这个接口所规定的方法，而子类可以从此类自动继承这些方法，这时候，这些子类具有了可插入性。<br>
<br>
我们关心的不是哪一个具体的类，而是这个类是否实现了我们需要的接口。<br>
<br>
接口提供了关联以及方法调用上的可插入性，软件系统的规模越大，生命周期越长，接口使得软件系统的灵活性和可扩展性，可插入性方面得到保证。<br>
<br>
接口在面向对象的 Java 程序设计中占有举足轻重的地位。事实上在设计阶段最重要的任务之一就是设计出各部分的接口，然后通过接口的组合，形成程序的基本框架结构。
<h2>
接口的使用</h2>
接口的使用与类的使用有些不同。在需要使用类的地方，会直接使用new关键字来构建一个类的实例，但接口不可以这样使用，因为接口不能直接使用 new 关键字来构建实例。<br>
<br>
接口必须通过类来实现(implements)它的抽象方法，然后再实例化类。类实现接口的关键字为implements。<br>
<br>
如果一个类不能实现该接口的所有抽象方法，那么这个类必须被定义为抽象方法。<br>
<br>
不允许创建接口的实例，但允许定义接口类型的引用变量，该变量指向了实现接口的类的实例。<br>
<br>
一个类只能继承一个父类，但却可以实现多个接口。<br>
<br>
实现接口的格式如下：<br>
修饰符 class 类名 extends 父类 implements 多个接口 {<br>
    实现方法<br>
}<br>
<br>
请看下面的例子：
<pre class="java">
import static java.lang.System.*;

public class Demo{
  public static void main(String[] args) {
      SataHdd sh1=new SeagateHdd(); //初始化希捷硬盘
      SataHdd sh2=new SamsungHdd(); //初始化三星硬盘
  }
}

//串行硬盘接口
interface SataHdd{
    //连接线的数量
    public static final int CONNECT_LINE=4;
    //写数据
    public void writeData(String data);
    //读数据
    public String readData();
}

// 维修硬盘接口
interface fixHdd{
    // 维修地址
    String address = "北京市海淀区";
    // 开始维修
    boolean doFix();
}

//希捷硬盘
class SeagateHdd implements SataHdd, fixHdd{
    //希捷硬盘读取数据
    public String readData(){
        return "数据";
    }
    //希捷硬盘写入数据
    public void writeData(String data) {
        out.println("写入成功");
    }
    // 维修希捷硬盘
    public boolean doFix(){
        return true;
    }
}
//三星硬盘
class SamsungHdd implements SataHdd{
    //三星硬盘读取数据
    public String readData(){
        return "数据";
    }
    //三星硬盘写入数据
    public void writeData(String data){
        out.println("写入成功");
    }
}
//某劣质硬盘，不能写数据
abstract class XXHdd implements SataHdd{
    //硬盘读取数据
    public String readData() {
        return "数据";
    }
}</pre>
<h2>
接口作为类型使用</h2>
接口作为引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类中所实现的接口中的方法，Java 运行时系统会动态地确定应该使用哪个类中的方法，实际上是调用相应的实现类的方法。<br>
<br>
示例如下：
<pre class="java">
public class Demo{
    public void test1(A a) {
        a.doSth();
    }
    public static void main(String[] args) {
        Demo d = new Demo();
        A a = new B();
        d.test1(a);
    }
}
interface A {
    public int doSth();
}
class B implements A {
    public int doSth() {
        System.out.println("now in B");
        return 123;
    }
}</pre>
运行结果：<br>
now in B<br>
<br>
大家看到接口可以作为一个类型来使用，把接口作为方法的参数和返回类型。</div>

http://www.weixueyuan.net/view/6009.html
<h1>Java接口和抽象类的区别</h1>
<div id="art-body">类是对象的模板，抽象类和接口可以看做是具体的类的模板。<br>
<br>
由于从某种角度讲，接口是一种特殊的抽象类，它们的渊源颇深，有很大的相似之处，所以在选择使用谁的问题上很容易迷糊。我们首先分析它们具有的相同点。
<ul>
<li>
都代表类树形结构的抽象层。在使用引用变量时，尽量使用类结构的抽象层，使方法的定义和实现分离，这样做对于代码有松散耦合的好处。</li>
<li>
都不能被实例化。</li>
<li>
都能包含抽象方法。抽象方法用来描述系统提供哪些功能，而不必关心具体的实现。</li>
</ul>
<br>
下面说一下抽象类和接口的主要区别。<br>
<br>
1) 抽象类可以为部分方法提供实现，避免了在子类中重复实现这些方法，提高了代码的可重用性，这是抽象类的优势；而接口中只能包含抽象方法，不能包含任何实现。
<pre class="java">
public abstract class A{
    public abstract void method1();
    public void method2(){
        //A method2
    }
}
public class B extends A{
    public void method1(){
        //B method1
    }
}
public class C extends A{
    public void method1(){
        //C method1
    }
}</pre>
抽象类A有两个子类B、C，由于A中有方法method2的实现，子类B、C中不需要重写method2方法，我们就说A为子类提供了公共的功能，或A约束了子类的行为。method2就是代码可重用的例子。A 并没有定义 method1的实现，也就是说B、C 可以根据自己的特点实现method1方法，这又体现了松散耦合的特性。<br>
<br>
再换成接口看看：
<pre class="java">
public interface A{
    public void method1();
    public void method2();
}
public class B implements A{
    public void method1(){
        //B method1
    }
    public void method2(){
        //B method2
    }
}
public class C implements A{
    public void method1(){
        //C method1
    }
    public void method2(){
        //C method2
    }
}</pre>
接口A无法为实现类B、C提供公共的功能，也就是说A无法约束B、C的行为。B、C可以自由地发挥自己的特点现实 method1和 method2方法，接口A毫无掌控能力。<br>
<br>
2) 一个类只能继承一个直接的父类（可能是抽象类），但一个类可以实现多个接口，这个就是接口的优势。
<pre class="java">
interface A{
    public void method2();
}
interface B{
    public void method1();
}
class C implements A,B{
    public void method1(){
        //C method1
    }
    public void method2(){
        //C method2
    }
}
//可以如此灵活的使用C，并且C还有机会进行扩展，实现其他接口
A a=new C();
B b=new C();
abstract class A{
    public abstract void method1();
}
abstract class B extends A{
    public abstract void method2();
}
class C extends B{
    public void method1(){
        //C method1
    }
    public void method2() {
        //C method2
    }
}</pre>
对于C类，将没有机会继承其他父类了。<br>
<br>
综上所述，接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：
<ul>
<li>
行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li>
<li>
选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li>
</ul>
</div>

http://www.weixueyuan.net/view/6011.html
<h1>Java泛型详解，通俗易懂只需5分钟</h1>
<div id="art-body">我们知道，使用变量之前要定义，定义一个变量时必须要指明它的数据类型，什么样的数据类型赋给什么样的值。<br>
<br>
假如我们现在要定义一个类来表示坐标，要求坐标的数据类型可以是整数、小数和字符串，例如：
<ul>
<li>
x = 10、y = 10</li>
<li>
x = 12.88、y = 129.65</li>
<li>
x = "东京180度"、y = "北纬210度"</li>
</ul>
<br>
针对不同的数据类型，除了借助方法重载，还可以借助自动装箱和向上转型。我们知道，基本数据类型可以自动装箱，被转换成对应的包装类；Object 是所有类的祖先类，任何一个类的实例都可以向上转型为 Object 类型，例如：
<ul>
<li>
int --&gt; Integer --&gt; Object</li>
<li>
double --&gt;Double --&gt; Object</li>
<li>
String --&gt; Object</li>
</ul>
<br>
这样，只需要定义一个方法，就可以接收所有类型的数据。请看下面的代码：
<pre class="java">
public class Demo {
    public static void main(String[] args){
        Point p = new Point();

        p.setX(10);  // int -&gt; Integer -&gt; Object
        p.setY(20);
        int x = (Integer)p.getX();  // 必须向下转型
        int y = (Integer)p.getY();
        System.out.println("This point is：" + x + ", " + y);
       
        p.setX(25.4);  // double -&gt; Integer -&gt; Object
        p.setY("东京180度");
        double m = (Double)p.getX();  // 必须向下转型
        double n = (Double)p.getY();  // 运行期间抛出异常
        System.out.println("This point is：" + m + ", " + n);
    }
}

class Point{
    Object x = 0;
    Object y = 0;

    public Object getX() {
        return x;
    }
    public void setX(Object x) {
        this.x = x;
    }
    public Object getY() {
        return y;
    }
    public void setY(Object y) {
        this.y = y;
    }
}</pre>
上面的代码中，生成坐标时不会有任何问题，但是取出坐标时，要向下转型，在 <a href="/view/6002.html" target="_blank">Java多态对象的类型转换</a> 一文中我们讲到，向下转型存在着风险，而且编译期间不容易发现，只有在运行期间才会抛出异常，所以要尽量避免使用向下转型。运行上面的代码，第12行会抛出 java.lang.ClassCastException 异常。<br>
<br>
那么，有没有更好的办法，既可以不使用重载（有重复代码），又能把风险降到最低呢？<br>
<br>
有，可以使用<span style="color:#b22222;">泛型类(Java Class)</span>，它可以接受任意类型的数据。所谓“泛型”，就是“宽泛的数据类型”，任意的数据类型。<br>
<br>
更改上面的代码，使用泛型类：
<pre class="java">
public class Demo {
    public static void main(String[] args){
        // 实例化泛型类
        Point&lt;Integer, Integer&gt; p1 = new Point&lt;Integer, Integer&gt;();
        p1.setX(10);
        p1.setY(20);
        int x = p1.getX();
        int y = p1.getY();
        System.out.println("This point is：" + x + ", " + y);
       
        Point&lt;Double, String&gt; p2 = new Point&lt;Double, String&gt;();
        p2.setX(25.4);
        p2.setY("东京180度");
        double m = p2.getX();
        String n = p2.getY();
        System.out.println("This point is：" + m + ", " + n);
    }
}

// 定义泛型类
class Point&lt;T1, T2&gt;{
    T1 x;
    T2 y;
    public T1 getX() {
        return x;
    }
    public void setX(T1 x) {
        this.x = x;
    }
    public T2 getY() {
        return y;
    }
    public void setY(T2 y) {
        this.y = y;
    }
}</pre>
运行结果：<br>
This point is：10, 20<br>
This point is：25.4, 东京180度<br>
<br>
与普通类的定义相比，上面的代码在类名后面多出了 &lt;T1, T2&gt;，T1, T2 是自定义的标识符，也是参数，用来传递数据的类型，而不是数据的值，我们称之为<span style="color:#b22222;">类型参数</span>。在泛型中，不但数据的值可以通过参数传递，数据的类型也可以通过参数传递。T1, T2 只是数据类型的占位符，运行时会被替换为真正的数据类型。<br>
<br>
传值参数（我们通常所说的参数）由小括号包围，如 (int x, double y)，类型参数（泛型参数）由尖括号包围，多个参数由逗号分隔，如 &lt;T&gt; 或 &lt;T, E&gt;。<br>
<br>
类型参数需要在类名后面给出。一旦给出了类型参数，就可以在类中使用了。类型参数必须是一个合法的标识符，习惯上使用单个大写字母，通常情况下，K 表示键，V 表示值，E 表示异常或错误，T 表示一般意义上的数据类型。<br>
<br>
泛型类在实例化时必须指出具体的类型，也就是向类型参数传值，格式为：<br>
    className variable&lt;dataType1, dataType2&gt; = new className&lt;dataType1, dataType2&gt;();<br>
也可以省略等号右边的数据类型，但是会产生警告，即：<br>
    className variable&lt;dataType1, dataType2&gt; = new className();<br>
<br>
因为在使用泛型类时指明了数据类型，赋给其他类型的值会抛出异常，既不需要向下转型，也没有潜在的风险，比本文一开始介绍的自动装箱和向上转型要更加实用。<br>
<br>
注意：
<ul>
<li>
泛型是 Java 1.5 的新增特性，它以C++模板为参照，本质是参数化类型(Parameterized Type)的应用。</li>
<li>
类型参数只能用来表示引用类型，不能用来表示基本类型，如  int、double、char 等。但是传递基本类型不会报错，因为它们会自动装箱成对应的包装类。</li>
</ul>
<h2>
泛型方法</h2>
除了定义泛型类，还可以定义泛型方法，例如，定义一个打印坐标的泛型方法：
<pre class="java">
public class Demo {
    public static void main(String[] args){
        // 实例化泛型类
        Point&lt;Integer, Integer&gt; p1 = new Point&lt;Integer, Integer&gt;();
        p1.setX(10);
        p1.setY(20);
        p1.printPoint(p1.getX(), p1.getY());
       
        Point&lt;Double, String&gt; p2 = new Point&lt;Double, String&gt;();
        p2.setX(25.4);
        p2.setY("东京180度");
        p2.printPoint(p2.getX(), p2.getY());
    }
}

// 定义泛型类
class Point&lt;T1, T2&gt;{
    T1 x;
    T2 y;
    public T1 getX() {
        return x;
    }
    public void setX(T1 x) {
        this.x = x;
    }
    public T2 getY() {
        return y;
    }
    public void setY(T2 y) {
        this.y = y;
    }
   
    // 定义泛型方法
    public &lt;T1, T2&gt; void printPoint(T1 x, T2 y){
        T1 m = x;
        T2 n = y;
        System.out.println("This point is：" + m + ", " + n);
    }
}</pre>
运行结果：<br>
This point is：10, 20<br>
This point is：25.4, 东京180度<br>
<br>
上面的代码中定义了一个泛型方法 printPoint()，既有普通参数，也有类型参数，类型参数需要放在修饰符后面、返回值类型前面。一旦定义了类型参数，就可以在参数列表、方法体和返回值类型中使用了。<br>
<br>
与使用泛型类不同，使用泛型方法时不必指明参数类型，编译器会根据传递的参数自动查找出具体的类型。泛型方法除了定义不同，调用就像普通方法一样。 <br>
<br>
注意：泛型方法与泛型类没有必然的联系，泛型方法有自己的类型参数，在普通类中也可以定义泛型方法。泛型方法 printPoint() 中的类型参数 T1, T2 与泛型类 Point 中的 T1, T2 没有必然的联系，也可以使用其他的标识符代替：
<pre class="java">
public static &lt;V1, V2&gt; void printPoint(V1 x, V2 y){
    V1 m = x;
    V2 n = y;
    System.out.println("This point is：" + m + ", " + n);
}</pre>
<h2>
泛型接口</h2>
在Java中也可以定义泛型接口，这里不再赘述，仅仅给出示例代码：
<pre class="java">
public class Demo {
    public static void main(String arsg[]) {
        Info&lt;String&gt; obj = new InfoImp&lt;String&gt;("www.weixueyuan.net");
        System.out.println("Length Of String: " + obj.getVar().length());
    }
}

//定义泛型接口
interface Info&lt;T&gt; {
    public T getVar();
}

//实现接口
class InfoImp&lt;T&gt; implements Info&lt;T&gt; {
    private T var;

    // 定义泛型构造方法
    public InfoImp(T var) {
        this.setVar(var);
    }

    public void setVar(T var) {
        this.var = var;
    }

    public T getVar() {
        return this.var;
    }
}</pre>
运行结果：<br>
Length Of String: 18
<h2>
类型擦除</h2>
如果在使用泛型时没有指明数据类型，那么就会擦除泛型类型，请看下面的代码：
<pre class="java">
public class Demo {
    public static void main(String[] args){
        Point p = new Point();  // 类型擦除
        p.setX(10);
        p.setY(20.8);
        int x = (Integer)p.getX();  // 向下转型
        double y = (Double)p.getY();
        System.out.println("This point is：" + x + ", " + y);
    }
}

class Point&lt;T1, T2&gt;{
    T1 x;
    T2 y;
    public T1 getX() {
        return x;
    }
    public void setX(T1 x) {
        this.x = x;
    }
    public T2 getY() {
        return y;
    }
    public void setY(T2 y) {
        this.y = y;
    }
}</pre>
运行结果：<br>
This point is：10, 20.8<br>
<br>
因为在使用泛型时没有指明数据类型，为了不出现错误，编译器会将所有数据向上转型为 Object，所以在取出坐标使用时要向下转型，这与本文一开始不使用泛型没什么两样。<br>
<h2>
限制泛型的可用类型</h2>
在上面的代码中，类型参数可以接受任意的数据类型，只要它是被定义过的。但是，很多时候我们只需要一部分数据类型就够了，用户传递其他数据类型可能会引起错误。例如，编写一个泛型函数用于返回不同类型数组（Integer 数组、Double 数组、Character 数组等）中的最大值：
<pre class="java">
public &lt;T&gt; T getMax(T array[]){
    T max = null;
    for(T element : array){
        max = element.doubleValue() &gt; max.doubleValue() ? element : max;
    }
    return max;
}</pre>
上面的代码会报错，doubleValue() 是 Number 类的方法，不是所有的类都有该方法，所以我们要限制类型参数 T，让它只能接受 Number 及其子类（Integer、Double、Character 等）。<br>
<br>
通过 extends 关键字可以限制泛型的类型，改进上面的代码：
<pre class="java">
public &lt;T extends Number&gt; T getMax(T array[]){
    T max = null;
    for(T element : array){
        max = element.doubleValue() &gt; max.doubleValue() ? element : max;
    }
    return max;
}</pre>
&lt;T extends Number&gt; 表示 T 只接受 Number 及其子类，传入其他类型的数据会报错。这里的限定使用关键字 extends，后面可以是类也可以是接口。但这里的 extends 已经不是继承的含义了，应该理解为 T 是继承自 Number 类的类型，或者 T 是实现了 XX 接口的类型。<br>
<br>
注意：一般的应用开发中泛型使用较少，多用在框架或者库的设计中，这里不再深入讲解，主要让大家对泛型有所认识，为后面的教程做铺垫。</div>

http://www.weixueyuan.net/view/6321.html
<h1>java泛型通配符和类型参数的范围</h1>
<div id="art-body">本节先讲解如何限制类型参数的范围，再讲解通配符(?)。
<h2>
类型参数的范围</h2>
在泛型中，如果不对类型参数加以限制，它就可以接受任意的数据类型，只要它是被定义过的。但是，很多时候我们只需要一部分数据类型就够了，用户传递其他数据类型可能会引起错误。例如，编写一个泛型函数用于返回不同类型数组（Integer 数组、Double 数组等）中的最大值：
<pre class="java">
public &lt;T&gt; T getMax(T array[]){
    T max = null;
    for(T element : array){
        max = element.doubleValue() &gt; max.doubleValue() ? element : max;
    }
    return max;
}</pre>
上面的代码会报错，doubleValue() 是 Number 类及其子类的方法，不是所有的类都有该方法，所以我们要限制类型参数 T，让它只能接受 Number 及其子类（Integer、Double、Character 等）。<br>
<br>
通过 extends 关键字可以限制泛型的类型的上限，改进上面的代码：
<pre class="java">
public &lt;T extends Number&gt; T getMax(T array[]){
    T max = null;
    for(T element : array){
        max = element.doubleValue() &gt; max.doubleValue() ? element : max;
    }
    return max;
}</pre>
&lt;T extends Number&gt; 表示 T 只接受 Number 及其子类，传入其他类型的数据会报错。这里的限定使用关键字 extends，后面可以是类也可以是接口。如果是类，只能有一个；但是接口可以有多个，并以“&amp;”分隔，例如 &lt;T extends Interface1 &amp; Interface2&gt;。<br>
<br>
这里的 extends 关键字已不再是继承的含义了，应该理解为 T 是继承自 Number 类的类型，或者 T 是实现了 XX 接口的类型。
<h2>
通配符(?)</h2>
上一节的例子中提到要定义一个泛型类来表示坐标，坐标可以是整数、小数或字符串，请看下面的代码：
<pre class="java">
class Point&lt;T1, T2&gt;{
    T1 x;
    T2 y;
    public T1 getX() {
        return x;
    }
    public void setX(T1 x) {
        this.x = x;
    }
    public T2 getY() {
        return y;
    }
    public void setY(T2 y) {
        this.y = y;
    }
}</pre>
现在要求在类的外部定义一个 printPoint() 方法用于输出坐标，怎么办呢？<br>
<br>
可以这样来定义方法：
<pre class="java">
public void printPoint(Point p){
    System.out.println("This point is: " + p.getX() + ", " + p.getY());
}</pre>
我们知道，如果在使用泛型时没有指名具体的数据类型，就会擦除泛型类型，并向上转型为 Object，这与不使用泛型没什么两样。上面的代码没有指明数据类型，相当于：
<pre class="java">
public void printPoint(Point&lt;Object, Object&gt; p){
    System.out.println("This point is: " + p.getX() + ", " + p.getY());
}</pre>
为了避免类型擦除，可以使用通配符(?)：
<pre class="java">
public void printPoint(Point&lt;?, ?&gt; p){
    System.out.println("This point is: " + p.getX() + ", " + p.getY());
}</pre>
通配符(?)可以表示任意的数据类型。将代码补充完整：
<pre class="java">
public class Demo {
    public static void main(String[] args){
        Point&lt;Integer, Integer&gt; p1 = new Point&lt;Integer, Integer&gt;();
        p1.setX(10);
        p1.setY(20);
        printPoint(p1);
      
        Point&lt;String, String&gt; p2 = new Point&lt;String, String&gt;();
        p2.setX("东京180度");
        p2.setY("北纬210度");
        printPoint(p2);
    }
   
    public static void printPoint(Point&lt;?, ?&gt; p){  // 使用通配符
        System.out.println("This point is: " + p.getX() + ", " + p.getY());
    }
}

class Point&lt;T1, T2&gt;{
    T1 x;
    T2 y;
    public T1 getX() {
        return x;
    }
    public void setX(T1 x) {
        this.x = x;
    }
    public T2 getY() {
        return y;
    }
    public void setY(T2 y) {
        this.y = y;
    }
}</pre>
运行结果：<br>
This point is: 10, 20<br>
This point is: 东京180度, 北纬210度<br>
<br>
但是，数字坐标与字符串坐标又有区别：数字可以表示x轴或y轴的坐标，字符串可以表示地球经纬度。现在又要求定义两个方法分别处理不同的坐标，一个方法只能接受数字类型的坐标，另一个方法只能接受字符串类型的坐标，怎么办呢？<br>
<br>
这个问题的关键是要限制类型参数的范围，请先看下面的代码：
<pre class="java">
public class Demo {
    public static void main(String[] args){
        Point&lt;Integer, Integer&gt; p1 = new Point&lt;Integer, Integer&gt;();
        p1.setX(10);
        p1.setY(20);
        printNumPoint(p1);
      
        Point&lt;String, String&gt; p2 = new Point&lt;String, String&gt;();
        p2.setX("东京180度");
        p2.setY("北纬210度");
        printStrPoint(p2);
    }
   
    // 借助通配符限制泛型的范围
    public static void printNumPoint(Point&lt;? extends Number, ? extends Number&gt; p){
        System.out.println("x: " + p.getX() + ", y: " + p.getY());
    }
   
    public static void printStrPoint(Point&lt;? extends String, ? extends String&gt; p){
        System.out.println("GPS: " + p.getX() + "，" + p.getY());
    }
}

class Point&lt;T1, T2&gt;{
    T1 x;
    T2 y;
    public T1 getX() {
        return x;
    }
    public void setX(T1 x) {
        this.x = x;
    }
    public T2 getY() {
        return y;
    }
    public void setY(T2 y) {
        this.y = y;
    }
}</pre>
运行结果：<br>
x: 10, y: 20<br>
GPS: 东京180度，北纬210度<br>
<br>
? extends Number 表示泛型的类型参数只能是 Number 及其子类，? extends String 也一样，这与定义泛型类或泛型方法时限制类型参数的范围类似。<br>
<br>
不过，使用通配符(?)不但可以限制类型的上限，还可以限制下限。限制下限使用 super 关键字，例如 &lt;? super Number&gt; 表示只能接受 Number 及其父类。<br>
<br>
注意：一般的项目中很少会去设计泛型，这里主要是让读者学会如何使用，为后面的教程做铺垫。</div>

http://www.weixueyuan.net/view/6323.html