
<h1>Java绘图基础</h1>
<div id="art-body">要在平面上显示文字和绘图，首先要确定一个平面坐标系。<span style="color:#b22222;">Java语言约定，显示屏上一个长方形区域为程序绘图区域，坐标原点(0,0）位于整个区域的左上角。</span>一个坐标点（x,y）对应屏幕窗口中的一个像素，是整数。如图12.1所示。窗口大小由超文本文件中的width和height指定。例如，以下超文本确定窗口宽为250像素，高为400像素：<br>
     &lt;applet code = h.class width=250 height=400&gt;&lt;/applet&gt;<br>
<span style="font-size:13px;">注：applet是一种嵌入网页的Java小程序，由于目前极少使用，本教程不再进行讲解，这里仅作示例参考。</span>
<div style="text-align: center; ">
<img alt="" src="http://www.weixueyuan.net/uploads/allimg/130224/8-130224220615W4.png" style="width: 254px; height: 160px; "><br>
图12.1</div>
<br>
<strong>raphics类的基本功能</strong><br>
在java.awt包中，类Graphics提供的功能有：<span style="color:#b22222;">建立字体、设定显示颜色、显示图像和文本，绘制和填充各种几何图形</span>。可以从图形对象或使用Component的getGraphics()方法得到Graphics对象。Graphics2D类继承Graphics类，并且增加了许多状态属性，使应用程序可以绘制出更加丰富多彩的图形。<br>
<br>
在某个组件中绘图，一般应该为这个组件所属的子类重写paint()方法，在该重写的方法中进行绘图。但要在JComponent子类中进行绘图。例如，继承定义一个文本区子类，要在这样的文本区子对象中绘图，就应给这个文本区子类重写paintComponent()。系统自动为程序提供图形对象，并以参数g传递给paint()方法和paintComponent()方法。</div>

http://www.weixueyuan.net/view/6070.html
<h1>Java绘图之设置字型和颜色</h1>
<div id="art-body">Java绘图中，显示文字的方法主要有三种：<br>
（1）drawString(String str,int x,int y)：在指定的位置显示字符串。<br>
（2）drawChars(char data[],int offset,int length, int x, int y)：在指定的位置显示字符数组中的文字，从字符数组的offset位置开始，最多显示length个字符。<br>
（3）drawBytes(byte data[],int offset,int length,int x,int y), 在指定的位置显示字符数组中的文字，从字符数组的offset位置开始，最多显示length个字符。<br>
<br>
这里给出的显示位置(x,y)为文字的基线的开始坐标，不是文字显示的矩形区域的左上角坐标。<br>
<br>
文字字型有三个要素：
<ul>
<li>
字体：常用的字体有Times New Roman、Symbol、宋体、楷体等。</li>
<li>
风格：常用的风格有三种：正常、粗体和斜体；分别用三个常量表示：Font.PLAIN(正常)、Font.BOLD(粗体)和Font.ITALIC（斜体）。风格可以组合使用，例如 ，Font.BOLD+Font.ITALIC。</li>
<li>
字号：字号是字的大小，单位是磅。</li>
</ul>
<br>
<span style="color:#b22222;">在Java语言中，用类Font对象字型。</span>Font类构造方法有：<br>
    Font(String fontName,int style,int size),3个参数分别表示字体、风格和字号。例如，代码：<br>
    Font fnA = new Font(“细明本”,Font.PLAIN,12)<br>
设置的字型的是：细明体、正常风格， 12磅字号。<br>
<br>
Font类的其他常用方法：
<ol>
<li>
getStyle()，返回字体风格。</li>
<li>
getSize()，返回字体大小。</li>
<li>
getName()，返回字体名称。</li>
<li>
isPlain()，测试字体是否是正常字体。</li>
<li>
isBold(),测试字体是否是粗体。</li>
<li>
isItalic()，测试字体是否是斜体。</li>
</ol>
<br>
【例 12-1】小应用程序用6种字型字符串，显示内容说明本身的字型。<br>
import java.applet.*;<br>
import java.awt.*;<br>
public class Example7_1 extends Applet{<br>
    Font f1 = new Font("Helvetica",Font.PLAIN,18);<br>
    Font f2 = new Font("Helvetica", Font.BOLD,10);<br>
    Font f3 = new Font("Helvetica",Font.ITALIC,12);<br>
    Font f4 = new Font("Courier",Font.PLAIN,12);<br>
    Font f5 = new Font("TimesRoman", Font.BOLD+Font.ITALIC,14);<br>
    Font f6 = new Font("Dialog",Font.ITALIC,14);<br>
    public void paint(Graphics g){<br>
        setSize(250,200);<br>
        g.setFont(f1);drawString("18pt plain Helvetica",5,20);<br>
        g.setFont(f2);drawString("10pt bold Helvetica",5,43);<br>
        g.setFont(f3);drawString("12pt italic Helvetica",5,58);<br>
        g.setFont(f4);drawString("12pt plain courier",5,75);<br>
        g.setFont(f5);drawString("14pt bold &amp; italic times Roman",5,92);<br>
        g.setFont(f6);drawString("14pt italic dialog",5,111);<br>
    }<br>
}<br>
<br>
用类Color的对象设置颜色，有两种方法生成各种颜色：
<ul>
<li>
用类Color预定议的颜色：black，red, white, yellow ……；</li>
<li>
通过红绿蓝（RGB）的值合成颜色。</li>
</ul>
<br>
与颜色有关的常用方法：<br>
（1）用类Color的构造方法Color（int R, int G,int B）创建一个颜色对象，参数R,G,B分别表示红色、绿色和蓝色，它们的取值是从0到255。<br>
（2）用类Graphics的方法setColor(Color c)，参数c的取值参见表12-1。<br>
（3）用类Component的方法setBackground(Color c)设置背景颜色。因为小程序是组件类的子类，直接可用setBackground()方法改变背景色。<br>
（4）用类Graphics的方法getColor()获取颜色。<br>
<table>
<caption>
表12-1 Color 类预定义颜色常量</caption>
<tbody>
<tr>
<td>
black</td>
<td>
blue</td>
<td>
cyan</td>
</tr>
<tr>
<td>
darkGray</td>
<td>
gray</td>
<td>
green</td>
</tr>
<tr>
<td>
lightGray</td>
<td>
magenta</td>
<td>
orange</td>
</tr>
<tr>
<td>
pink</td>
<td>
red</td>
<td>
white</td>
</tr>
<tr>
<td>
yellow</td>
<td>
 </td>
<td>
 </td>
</tr>
</tbody>
</table>
<br>
【例 12-2】小应用程序设置颜色并涂方块，其中绘制方块的方法将在后续小节中讲到。<br>
import java.applet.*;<br>
import java.awt.*;<br>
public class Example7_2 extends Applet{<br>
    public void paint(Graphics g){<br>
        setSize(380,200);<br>
        for(int i=0;i&lt;=10;i++){<br>
            Color myredcolor = new Color(i*25+5,0,0);<br>
            g.setColor(myredcolor);<br>
            g.fillRect(i*32+5,2,28,28);<br>
        }<br>
        for(int i=0;i&lt;=10;i++){<br>
            Color mygreencolor = new Color(0,i*25+5,0);<br>
            g.setColor(mygreencolor);<br>
            g.fillRect(i*32+5,32,28,28);<br>
        }<br>
        for(int i=0;i&lt;=10;i++){<br>
            Color mybluecolor = new Color(0,0,i*25+5);<br>
            g.setColor(mybluecolor);<br>
            g.fillRect(i*32+5,62,28,28);<br>
        }<br>
    }<br>
}</div>

http://www.weixueyuan.net/view/6071.html
<h1>Java绘图模式概述</h1>
<div id="art-body"><span style="color:#b22222;">绘图模式是指后绘制的图形与早先绘制的图形有重叠时，如何确定重叠部分的颜色。</span>例如，后绘制的覆盖早先绘制的；或者后绘制与早先绘制的两种颜色按某种规则混合。主要有正常模式和异或模式两种：正常模式是后绘制的图形覆盖在早先绘制的图形之上，使早先贩图形的重叠部分不再可见。异或模式把绘图看作是按图形着色。异或模式绘图时，将当前正要绘图的颜色、原先绘制的颜色以及异或模式设定的颜色作特定的运算，得到实际绘图颜色。设置绘图模式的方法有：
<ul>
<li>
setPaintMode()：设置绘图模式为覆盖模式（正常模式）。正常模式是绘图的默认模式。</li>
<li>
setXORMode(Color c)：设置绘图模式为异或模式，参数c为异或模式设定的绘图颜色。</li>
</ul>
<br>
设背景色为B，用setXORMode()设置的颜色为C，另用某个非背景色D绘图，XOR模式有以下确定实际绘图颜色的法则：<br>
B + B = C,用背景色绘图，出现C颜色。<br>
D + D = B,当一个图形重画时就能清除原先画的图形。<br>
B + D = B和D的混合色（当B，D不相同时）。<br>
如果某区域已用D着色，再用E着色，则结果是：<br>
D + E = D和E的混合色（当D，E不相同时）。<br>
<br>
XOR绘图模式实例参见【<a href="http://www.weixueyuan.net/uploads/code/java/rumen/12-4.txt" target="_blank">例12-4</a>】</div>

http://www.weixueyuan.net/view/6072.html
<h1>Java Graphics类的绘图方法</h1>
<div id="art-body">Graphics类提供基本绘图方法，Graphics2D类提供更强大的绘图能力。本节讲解Graphics类，下节讲解Graphics2D。<br>
<br>
<span style="color:#b22222;">Graphics类提供基本的几何图形绘制方法，主要有：画线段、画矩形、画圆、画带颜色的图形、画椭圆、画圆弧、画多边形等。</span><br>
<br>
<strong>1. 画线</strong><br>
在窗口画一条线段，可以使用Graphics类的drawLine()方法：<br>
    drawLine(int x1,int y1,int x2,int y2)<br>
例如，以下代码在点（3,3）与点（50,50）之间画线段，在点（100,100）处画一个点。<br>
    g.drawLine(3,3,50,50);//画一条线段<br>
    g.drawLine(100,100,100,100);//画一个点。<br>
<br>
<strong>2. 画矩形</strong><br>
有两种矩形：普通型和圆角型。<br>
(1) 画普通矩形有两个方法：
<ul>
<li>
drawRect(int x,int y,int width,int height)：画线框围起来的矩形。其中参数x和y指定左上角的位置，参数width和height是矩形的宽和高。</li>
<li>
fillRect(int x,int y,int width,int height)：是用预定的颜色填充一个矩形，得到一个着色的矩形块。</li>
</ul>
以下代码是画矩形的例子：<br>
    g.drawRect(80,100,40,25);//画线框<br>
    g.setColor(Color.yellow);g.fillRect(20,70,20,30);//画着色块<br>
<br>
(2)画圆角矩形也有两个方法：
<ul>
<li>
drawRoundRect(int x,int y,int width, int height, int arcWidth, int arcHeight)：是用线围起来的圆角矩形。其中参数x和y指定矩形左上角的位置；参数width和heigth是矩形的宽和高；arcWidth和arcHeight分别是圆角弧的横向直径和圆角弧的纵向直径。</li>
<li>
fillRoundRect(int x,int y,int width,int height,int arcWidth,int archeight)：是用预定的颜色填充的圆角矩形。各参数的意义同前一个方法。</li>
</ul>
以下代码是画矩形的例子：<br>
    g.drawRoundRect(10,10,150,70,40,25);//画一个圆角矩形<br>
    g.setColor(Color.blue); g.fillRoundRect(80,100,100,100,60,40);//涂一个圆角矩形块<br>
    g.drawRoundRect(10,150,40,40,40,40);//画圆<br>
    g.setColor(Color.red); g.fillRoundRect(80,100,100,100,100,100);//画圆块<br>
可以用画圆角矩形方法画圆形，当矩形的宽和高相等，圆角弧的横向直径和圆角弧的纵向直径也相等，并等于矩形的宽和高时，画的就是圆形。参见上述例子中的注释，前一个是画圆，后一个是涂圆块。<br>
<br>
<strong>3. 画三维矩形</strong><br>
画三维矩形有两个方法：
<ul>
<li>
draw3DRect(int x,int y,int width,int height, boolean raised)：画一个突出显示的矩形。其中x和y指定矩形左上角的位置，参数width和height是矩形的宽和高，参数raised是突出与否。</li>
<li>
fill3DRect(int x,int y,int width,int height,boolean raised)：用预定的颜色填充一个突出显示的矩形。</li>
</ul>
以下代码是画突出矩形的例子：<br>
    g.draw3DRect(80,100,40,25,true);//画一个线框<br>
    g.setColor(Color.yellow); g.fill3DRect(20,70,20,30,true);//画一个着色块<br>
<br>
<strong>4.画椭圆形</strong><br>
椭圆形由椭圆的横轴和纵轴确定。画椭圆形有两个方法：
<ul>
<li>
drawOval(int x,int y,int width,int height)：是画用线围成的椭圆形。其中参数x和参数y指定椭圆形左上角的位置，参数width和height是横轴和纵轴。</li>
<li>
fillOval(int x,int y,int width,int height)：是用预定的颜色填充的椭圆形，是一个着色块。也可以用画椭圆形方法画圆形，当横轴和纵轴相等时，所画的椭圆形即为圆形。</li>
</ul>
以下代码是画椭圆形的例子：<br>
    g.drawOval(10,10,60,120);//画椭圆<br>
    g.setColor(Color.cyan);g.fillOval(100,30,60,60);//涂圆块<br>
    g.setColor(Color.magenta);g.fillOval(15,140,100,50);//涂椭圆<br>
<br>
<strong>5. 画圆弧</strong><br>
画圆弧有两个方法：
<ul>
<li>
drawArc(int x,int y,int width,int height,int startAngle, int arcAngle)：画椭圆一部分的圆弧线。椭圆的中心是它的外接矩形的中心，其中参数是外接矩形的左上角坐标(x,y)，宽是width，高是heigh。参数startAngle的单位是 “度”，起始角度0度是指3点钟方位.参数startAngle和arcAngle表示从startAngle角度开始，逆时针方向画arcAngle度的弧，约定，正值度数是逆时针方向，负值度数是顺时针方向，例如-90度是6点钟方位。</li>
<li>
fillArc(int x,int y,int width, int height, int startAngle, int arcAngle)：用setColor()方法设定的颜色,画着色椭圆的一部分。</li>
</ul>
以下代码是画圆弧的例子：<br>
    g.drawArc(10,40,90,50,0,180);//画圆弧线<br>
    g.drawArc(100,40,90,50,180,180);//画圆弧线<br>
    g.setColor(Color.yellow); g.fillArc(10,100,40,40,0,-270);//填充缺右上角的四分之三的椭圆<br>
    g.setColor(Color.green); g.fillArc(60,110,110,60,-90,-270);//填充缺左下角的四分之三的椭圆<br>
<br>
<strong>6. 画多边形</strong><br>
多边形是用多条线段首尾连接而成的封闭平面图。多边形线段端点的x坐标和y坐标分别存储在两个数组中，画多边形就是按给定的坐标点顺序用直线段将它们连起来。以下是画多边形常用的两个方法：
<ul>
<li>
drawPolygon(int xpoints[],int yPoints[],int nPoints)：画一个多边形</li>
<li>
fillPolygon(int xPoints[],int yPoints[],int nPoints)：用方法setColor()设定的颜色着色多边形。其中数组xPoints[]存储x坐标点，yPoints[]存储y坐标点，nPoints是坐标点个数。</li>
</ul>
<br>
注意，上述方法并不自动闭合多边形，要画一个闭合的多边形，给出的坐标点的最后一点必须与第一点相同.以下代码实现填充一个三角形和画一个八边形。<br>
    int px1[]={50,90,10,50};//首末点相重,才能画多边形 <br>
    int py1[]={10,50,50,10};<br>
    int px2[]={140,180,170,180,140,100,110,140};<br>
    int py2[]={5,25,35,45,65,35,25,5};<br>
    g.setColor(Color.blue);<br>
    g.fillPolygon(px1,py1,4);<br>
    g.setColor(Color.red);<br>
    g.drawPolygon(px2,py2,9);<br>
<br>
也可以用多边形对象画多边形。用多边形类Polygon创建一个多边形对象，然后用这个对象绘制多边形。Polygon类的主要方法：
<ul>
<li>
Polygon()：创建多边形对象，暂时没有坐标点。</li>
<li>
Polygon(int xPoints[],int yPoints[],int nPoints)：用指定的坐标点创建多边形对象。</li>
<li>
addPoint()：将一个坐标点加入到Polygon对象中。</li>
<li>
drawPolygon(Polygon p)：绘制多边形。 </li>
<li>
fillPolygon(Polygon p)：和指定的颜色填充多边形。</li>
</ul>
<br>
例如,以下代码，画一个三角形和填充一个黄色的三角形。注意，用多边形对象画封闭多边形不要求首末点重合。<br>
    int x[]={140,180,170,180,140,100,110,100};<br>
    int y[]={5,25,35,45,65,45,35,25};<br>
    Polygon ponlygon1=new Polygon();<br>
    polygon1.addPoint(50,10);<br>
    polygon1.addPoint(90,50);<br>
    polygon1.addPoint(10,50);<br>
    g.drawPolygon(polygon1);<br>
    g.setColor(Color.yellow);<br>
    Polygon polygon2 = new Polygon(x,y,8);<br>
    g.fillPolygon(polygon2);<br>
<br>
<strong>7. 擦除矩形块</strong><br>
当需要在一个着色图形的中间有一个空缺的矩形的情况，可用背景色填充一矩形块实现，相当于在该矩形块上使用了 “橡皮擦”.实现的方法是：<br>
    clearRect(int x,int y, int width,int height)：擦除一个由参数指定的矩形块的着色。<br>
例如，以下代码实现在一个圆中擦除一个矩形块的着色：<br>
    g.setColor(Color.blue);<br>
    g.fillOval(50,50,100,100);g.clearRect(70,70,40,55);<br>
<br>
<strong>8. 限定作图显示区域</strong><br>
用一个矩形表示图形的显示区域，要求图形在指定的范围内有效，不重新计算新的坐标值，自动实现超出部分不显示。方法是clipRect(int x,int y,int width,int height)，限制图形在指定区域内的显示，超出部分不显示。多个限制区有覆盖时，得到限制区域的<span style="color:#b22222;">交集区域</span>。例如，代码：<br>
    g.clipRect(0,0,100,50);g.clipRect(50,25,100,50);<br>
相当于<br>
    g.clipRect(50,25,50,25);<br>
<br>
<strong>9. 复制图形</strong><br>
利用Graphics类的方法copyArea()可以实现图形的复制,其使用格式是：<br>
    copyArea(int x,int y,int width,int height, int dx, int dy)，dx和dy分别表示将图形粘贴到原位置偏移的像素点数，正值为往右或往下偏移是，负值为往左或往上偏移量。位移的参考点是要复制矩形的左上角坐标。<br>
<br>
例如，以下代码示意图形的复制,将一个矩形的一部分、另一个矩形的全部分别自制。<br>
    g.drawRect(10,10,60,90);<br>
    g.fillRect(90,10,60,90);<br>
    g.copyArea(40,50,60,70,-20,80);<br>
    g.copyArea(110,50,60,60,10,80);<br>
<br>
【例12-3】小应用程序重写update()方法,只清除圆块，不清除文字，窗口显示一个不断移动的红色方块（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/12-3.txt" target="_blank">查看源文件</a>）。<br>
<br>
一般的绘图程序要继承JFrame，定义一个JFrame窗口子类，还要继承JPanel，定义一个JPanel子类。在JPanel子类 中重定义方法paintComponent()，在这个方法中调用绘图方法,绘制各种图形。<br>
<br>
【例12-4】使用XOR绘图模式的应用程序（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/12-4.txt" target="_blank">查看源文件</a>）。<br>
</div>

http://www.weixueyuan.net/view/6073.html
<h1>Java Graphics2D类的绘图方法</h1>
<div id="art-body">Java语言在Graphics类提供绘制各种基本的几何图形的基础上,扩展Graphics类提供一个Graphics2D类,它拥用更强大的二维图形处理能力,提供、坐标转换、颜色管理以及文字布局等更精确的控制。
<h2>
绘图属性</h2>
Graphics2D定义了几种方法，用于添加或改变图形的状态属性。可以通过设定和修改状态属性，指定画笔宽度和画笔的连接方式；设定平移、旋转、缩放或修剪变换图形；以及设定填充图形的颜色和图案等。图形状态属性用特定的对象存储。<br>
<br>
<strong>1. stroke属性</strong><br>
stroke属性控制线条的宽度、笔形样式、线段连接方式或短划线图案。该属性的设置需要先创建BasicStroke对象，再调用setStroke()方法来设置。创建BasicStroke对象的方法有：
<ul>
<li>
BasicStroke(float w)：指定线条宽w。</li>
<li>
BasicStroke(float w,int cap, int join)：
<ul>
<li>
cap是端点样：CAP_BUTT(无修饰)，CAP_ROUND(半圆形末端)，CAP_SQUARE(方形末端，默认值)。</li>
<li>
Join定义两线段交汇处的连接方式：JOIN_BEVEL(无修饰),JOIN_MTTER(尖形末端，默认值),JOIN_ROUND(圆形末端)。</li>
</ul>
</li>
</ul>
<br>
<strong>2. paint属性</strong><br>
paint属性控制填充效果。先调用以下方法确定填充效果，理用setPaint()方法设置。
<ul>
<li>
GradientPaint(float x1,float y1,Color c1,float x2,flaot y2,Color c2)：从(x1,y1)到(x2,y2)颜色从c1渐变到c2。其中：参数c1,c2决定这个渐变色是从颜色c1渐变到颜色c2。参数x1,y1,x2,y2决定了渐变的强弱，即要求从点(x1,y1)出发到达点(x2,y2)，颜色从c1变成c2。</li>
<li>
GradientPaint(float x1,float y1,Color c1,float x2,float y2,Color c2,Boolean cyclic)：如果希望渐变到终点又是起点的颜色，应将cyclic设置为true。</li>
</ul>
<br>
<strong>3. transform属性</strong><br>
transform 属性用来实现常用的图形平移、缩放和斜切等变换操作。首先创建AffineTransform对象，然后调用setTransform()方法设置transform属性。最后，用具有指定属性的Graphics2D对象绘制图形。创建AffineTransform对象的方法有：
<ul>
<li>
getRotateinstrance(double theta)：旋转theta弧度。</li>
<li>
getRotateInstance(double theta,dioble x,double y)：绕旋转中心(x,y)旋转。</li>
<li>
getScaleInstance(double sx,double sy)：x和y 方向分别按sx,sy比例变换。</li>
<li>
getTranslateInstance(double tx,double ty)：平移变换。</li>
<li>
getShearInstance(double shx,double shy)：斜切变换，shx和shy指定斜拉度。</li>
</ul>
<br>
也可以先创建一个没有transform属性的AffineTransform对象，然后用以下方法指定图形平移、旋转、缩放变换属性。
<ul>
<li>
transelate(double dx,double dy)：将图形在x轴方向平移dx像素。</li>
<li>
scale(double sx,double sy)：图形在x轴方向缩放sx倍，纵向缩放sy倍。</li>
<li>
rotate(double arc,double x, double y)：图形以点(x,y)为轴点，旋转arc弧度。</li>
</ul>
<br>
例如，创建AffineTransform对象：<br>
    AffineTransform trans = new AffineTransform();<br>
为AffineTransform对象指定绕点旋转变换属性：<br>
    Trans.rotate(50.0*3.1415927/180.0,90,80);<br>
接着为Graphics2D 的对象g2d设置具有上述旋转变换功能的“画笔”：<br>
    Graphics2D g2d = (Graphics2D)g;g2d.setTranstorm(trans);<br>
最后，以图形对象为参数调用具有变换功能的Graphics2D 对象的draw()方法。例如，设已有一个二次曲线对象curve，以下代码实现用上述旋转功能的g2d对象绘制这条二次曲线：<br>
    g2d.draw(curve);<br>
<br>
<strong>4. clip属性</strong><br>
clip属性用于实现剪裁效果。设置剪裁属性可调用setClip()方法确定剪裁区的Shape。连续多个setClip()得到它们交集的剪裁区。<br>
<br>
<strong>5. composit属性</strong><br>
composit属性设置图形重叠区域的效果。先用方法AlphaComposite.getInstance(int rule, float alpha)得到AlphaComposite对象，再通过setComposite()方法设置混合效果。Alpha值的范围为0.0f(完全透明)-0.1f(完全不透明)。
<h2>
Graphics2D类的绘图方法</h2>
Graphics2D类仍然保留Graphics类的绘图方法，同时增加了许多新方法。新方法将几何图形(线段、圆等)作为一个对象来绘制。在java.awt.geom包中声明的一系列类，分别用于创建各种身体图形对象。主要有：<br>
Line2D线段类，RoundRectangle2D圆角矩形类，Ellipse2D椭圆类，Arc2D圆弧类，QuadCurve2D二次曲线类，CubicCurve2D三次曲线类。<br>
<br>
要用Graphics2D类的新方法画一个图形。<span style="color:#b22222;">先在重画方法paintComponent()或paint()中，把参数对象g强制转换成Graphics2D对象；然后，用上述图形类提供的静态方法Double()创建该图形的对象；最后，以图形对象为参数调用Graphics2D对象的draw()方法绘制这个图形。</span>例如以下代码用Graphics2D的新方法绘制线段和圆角矩形：<br>
    Graphics2D g2d = (Graphics2D)g;//将对象g类型从Graphics转换成Graphics2D<br>
    Line2D line = new Line2D.Double(30.0,30.0,340.0,30.0);<br>
    g2d.draw(line);<br>
    RoundRectangle2D rRect = new RoundRectangle2D.Double(13.0,30.0,100.0,70.0,40.0,20.0);<br>
    g2d.draw(rRect);<br>
也可以先用java.awt.geom包提供的Shape对象，并用单精度Float坐标或双精度Double坐标创建Shape对象，然后再用draw()方法绘制。例如，以下代码先创建圆弧对象，然后绘制圆弧：<br>
    Shape arc = new Arc2D.Float(30,30,150,150,40,100,Arc2D.OPEN);<br>
    g2d.draw(arc)/绘制前面创建的图形对象arc
<h2>
Graphics2D的几何图形类</h2>
<ol>
<li>
线段<br>
    Line2D line = new Line2D.Double(2,3,200,300);//声明并创建线段对象<br>
    //起点是(2，3)，终点是(200，300)</li>
<li>
矩形<br>
    Rectangle2D rect = new Rectangle2D.Double(20,30,80,40);//声明并创建矩形对象，矩形的左上角是(20，30)，宽是300，高是40</li>
<li>
圆角矩形<br>
    RoundRectangle2D rectRound = new RoundRectangle2D.Double(20,30,130,100,18,15);<br>
    //左上角是(20，30)，宽是130，高是100，圆角的长轴是18，短轴是15。</li>
<li>
椭圆<br>
    Ellipse2D ellipse = new Ellipse2D.Double(20,30,100,50);<br>
    //左上角 (20，30)，宽是100，高是50</li>
<li>
圆弧<br>
    Arc2D arc1 = new Arc2D.Double(8,30,85,60,5,90,Arc2D.OPEN);<br>
    //外接矩形的左上角(10，30)，宽85，高60，起始角是5度，终止角是90度<br>
    Arc2D arc2 = new Arc2D.Double(20,65,90,70,0,180,Arc2D.CHORD);<br>
    Arc2D arc3 = new Arc2D.Double(40,110,50,90,0,270,Arc2D.PIE);<br>
参数Arc2D.OPEN、Arc2D.CHORD、Arc2D.PIE分别表示圆弧是开弧、弓弧和饼弧。</li>
<li>
二次曲线<br>
二次曲线用二阶多项式表示：<br>
    y(x)=ax2+bx+c<br>
一条二次曲线需要三个点确定：始点、控制点和终点。<br>
    QuadCurve2D curve1 = new QuadCurver2D.Double(20,10,90,65,55,115);<br>
    QuadCurve2D curve2 = new QuadCurver2D.Double(20,10,15,63,55,115);<br>
    QuadCurve2D curve3 = new QuadCurver2D.Double(20,10,54,64,55,115);<br>
方法Double()中的6个参数分别是二次曲线的始点、控制点和终点。以上3条二次曲线的开始点和终点分别相同。</li>
<li>
三次曲线<br>
三次曲线用三阶多项式表示：<br>
    y(x)=ax3+bx2+cx+d<br>
一条三次曲线需要四个点确定：始点、两个控制点和终点。<br>
    CubicCurve2D curve1 = new CubicCurve2D.Double(12,30,50,75,15,15,115,93);<br>
    CubicCurve2D curve2 = new CubicCurve2D.Double(12,30,15,70,20,25,35,94);<br>
    CubicCurve2D curve3 = new CubicCurve2D.Double(12,30,50,75,20,95,95,95);<br>
方法Double()中的8个参数分别是三次曲线的始点、两个控制点和终点。</li>
</ol>
<br>
一般的方程曲线的绘制过程用一个循环控制。通过循环产生自变量的值，按照方程计算出函数值，再作必要的坐标转换：原点定位的平移变换，图像缩小或放大的缩放变换，得到曲线的图像点，并绘制这个点。以绘制以下曲线方程为例：<br>
    Y=sin(x)+cos(x),x<br>
绘制的部分代码可以写成如下：<br>
double x0,y0,x1,y1,x2,y2,scale;<br>
x0=100;y0=80;<br>
scale =20.0;<br>
for(x1=-3.1415926d;x1&lt;=2*3.1415926d;x1+=0.01d){<br>
    y1=Math.sin(x1)+Math.cos(x1);<br>
    x2=x0+x1*scale;y2=y0+y1*scale;//(x2,y2)是图像点<br>
    g.fillOval((int)x2,(int)y2,1,1);//画一个圆点作为图像点<br>
}</div>

http://www.weixueyuan.net/view/6074.html
<h1>Java图像处理基础</h1>
<div id="art-body">图像是由一组像素构成，用二进制形式保存的图片。<span style="color:#b22222;">java语言支持GIF、JPEG和BMP这3种主要图像文件格式。</span>java语言的图像处理功能被封装在Image类中。
<h2>
图像载入和输出</h2>
在java程序中，图像也是对象，所以载入图像时，先要声明Image对象，然后，利用getImage()方法把Image对象与图像文件联系起来。载入图像文件的方法有两个：
<ul>
<li>
Image getImage(URL url),url指明图像所在位置和文件名。</li>
<li>
Image getImage(URL url,String name),url指明图像所在位置，name是文件名。</li>
</ul>
<br>
例如，以下代码声明Image对象，并用getImage()对象与图像文件联系起来：<br>
    Image img = getImage(getCodeBase(),”family.jpg”);<br>
URL(uniform Resource Location 统一资源定位符)对象用于标识资源的名字和地址，在WWW客户机访问Internet网上资源时使用。确定图像位置的方法有两种：绝对位置与相对位置。取相对位置的方法有：
<ul>
<li>
URL getCodeBase(),取小应用程序文件所在的位置。</li>
<li>
URL getDocumentBase(),取HTML文件所在的位置。</li>
</ul>
<br>
例如，代码：<br>
    URL picURLA = new URL(getDocumentBase(),”imageSample1.gif”),<br>
        picURLB = new URL(getDocumentBase(),”pictures/imageSample.gif”);<br>
    Image imageA = getImage(picURLA),imageB = getImage(picURLB);<br>
<br>
获取图像信息(属性)的方法有：
<ul>
<li>
getWidth(ImageObserver observer)：取宽度；</li>
<li>
getHeight(ImageObserver observer)：取高度。</li>
</ul>
<br>
输出图像的代码写在paint()方法中，有4种显示图像的方法：
<ul>
<li>
boolean drawImage(Image img,int x,int y,ImageObserver observer)</li>
<li>
boolean drawImage(Image img,int x,int y,Color bgcolor,ImageObserver observer)</li>
<li>
boolean drawImage(Image img,int x,int y,int width,int height,ImageObsever observer)</li>
<li>
boolean drawImage(Image img,int x,int y,int width,int height,Color bgcolor,ImageObsever observer)</li>
</ul>
参数img是Image对象，x,y是绘制图像矩形的左上角位置，observer是加载图像时的图像观察器，bgcolor是显示图像用的底色，width和height是显示图像的矩形区域，当这个区域与图像的大小不同时，显示图像就会有缩放处理。<br>
<br>
Applet类也实现ImageObserver接口，常用this作为实参。参见以下代码及注释：
<ul>
<li>
(1) g.drawImage(image1,0,0,this);//原图显示</li>
<li>
(2) g.drawImage(image2,10,10,Color.red,this);//图形加底色显示<br>
注意：如原图的大小与给定的范围不同，系统会自动缩放</li>
<li>
(3) g.drawImage(labImag,0,0,this);// 原图显示</li>
<li>
(4) g.grawImage(labImag,0,120,100,100,this);//缩放显示</li>
<li>
(5) g.grawImage(labImag,0,240,500,100,this);//缩放显示</li>
</ul>
<br>
【例 12-5】小应用程序用init()或start()方法下载(获取)图像，用paint()方法显示得到的图像。<br>
import java.applet.*;import java.awt.*;<br>
public class Example7_5 extends Applet{<br>
    Image myImag;<br>
    public void start(){<br>
        myImag = getImage(getCodeBase(),”myPic.jpg”);<br>
    }<br>
    public void paint(Graphics g){<br>
        g.drawImage(myImg,2,2,this);<br>
    }<br>
}<br>
<br>
由于在Frame、JFrame和JPanel等类中没有提供getImage()方法，它们载入图像需要使用java.awt.Toolkit中的Toolkit抽象类，该类有载入图像文件的方法：
<ul>
<li>
Image.getImage(String name)：按指定的文件名载入图像文件。</li>
<li>
Image.getImage(URL url)：统一资源定位符载入图像文件。</li>
</ul>
<br>
这样，各种组件可以用getToolkit()方法得到Toolkit对象，然后在组件的paint()方法中通过Toolkit对象显示图像。以下代码示意这样的用法：<br>
    Toolkit tool = getToolkit();<br>
    URL url = new URL(http://www.weixueyuan.net/image.gif);<br>
    Image img = tool.getImage(url);<br>
组件也可以使用Toolkit提供的静态方法getDefaultToolkit()获得一个缺省的Toolkit对象,并用它加载图像。此时，载入图像的代码常写成这样：<br>
    Image img = Toolkit.getDefaultToolkit().getImage(url);</div>

http://www.weixueyuan.net/view/6075.html
<h1>Java图像缓冲技术</h1>
<div id="art-body">当图像信息量较大，采用以上直接显示的方法，可能前面一部分显示后，显示后面一部分时，由于后面一部分还未从文件读出，使显示呈斑驳现象。为了提高显示效果，许多应用程序都采用图像缓冲技术，即先把图像完整装入内存，在缓冲区中绘制图像或图形，然后将缓冲区中绘制好的图像或图形一次性输出在屏幕上。缓冲技术不仅可以解决闪烁问题，并且由于在计算机内存中创建图像，程序可以对图像进行像素级处理，完成复杂的图像变换后再显示。<br>
<br>
【例 12-6】小应用程序程序演示图像缓冲显示技术。程序运行时，当鼠标在图像区域内按下时，图像会出现边框，托动鼠标时，图像也随之移动。抬起鼠标后，边框消失。程序将两种状态的图像先放入两个缓冲区，当鼠标拖动时，不断地在新的位置重绘鼠标按下样式的图像鼠标抬起时，重绘鼠标抬起样式的图像（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/12-6.txt" target="_blank">查看源文件</a>）。<br>
<br>
程序要创建缓冲区图像，需要引入java.awt.image包中的BufferedImage类。要创建一个缓冲区图，可以调用createImage()方法，该方法返回一个Image对象，然后再将它转换成一个BufferedImage对象。例如，代码：<br>
    BufferedImage bimage = (BufferedImage)this.createImage(this.getWidth(),this.getHeight());<br>
也可利用以下构造方法来建立。<br>
    BufferedImage(int width,int heigh, int imageType);<br>
其中参数 imageType是图像类型。<br>
<br>
使用缓冲区显示图像，需先在缓冲区中准备好图像，再将缓冲区中的图像显示在界面上。显示图像需要图形对象Graphics,可以通过以下方法建立：<br>
    Graphics2D g2d = bimge.createGraphics();</div>

http://www.weixueyuan.net/view/6076.html
<h1>Java多媒体基础</h1>
<div id="art-body">本节介绍 Java程序播放幻灯片和动画，播放声音和视频的方法。
<h2>
播放幻灯片和动画</h2>
用实例说明播放幻灯片和动画的方法。<br>
<br>
【例 12-7】小应用程序先将幻灯片读入数组在存储，单击鼠标变换幻灯片，逐张显示（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/12-7.txt" target="_blank">查看源文件</a>）。<br>
<br>
【例 12-8】小应用程序说明播放动画的方法，要求播放的图片和小程序放在相同的目录中，程序通过快速显示一组图片造成显示动画的效果。小应用程序利用线程控制动画图片的逐显示（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/12-8.txt" target="_blank">查看源文件</a>）。<br>
<h2>
播放声音</h2>
Java语言老根据地的音频格式有多种：au、aiff、wav、midi、rfm等。小程序要播放音频文件，可使用类AudioClip,该类在java.applet.AudioClip类库中定义。小程序先创建AudioClip对象，并用getAudioClip()方法为其初始化。代码形式如下：<br>
    AudioClip audioClip = getAudioClip(getCodeBase(),”myAudioClipFile.au”);<br>
如果要从网上获得音频文件，可用方法getAudioClip(URL url, String name),根据url地址及音频文件name获得可播放的音频对象。<br>
<br>
<span style="color:#b22222;">控制声音的播放有3个方法：play()播放声音，loop()循环播放和stop()停止播放。</span><br>
<br>
【例 12-9】能播放声音的小应用程序（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/12-9.txt" target="_blank">查看源文件</a>）。<br>
<br>
【例 12-10】如果声音文件较大或网络速度慢会影响小程序的初始化工作。这可用多线程技术解决。在一个级别较低的线程中完成音频对象的创建，即由后台载入声音文件，前台播放（<a href="http://www.weixueyuan.net/uploads/code/java/rumen/12-10.txt" target="_blank">查看源文件</a>）。<br>
</div>

http://www.weixueyuan.net/view/6077.html